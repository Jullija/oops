schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  refresh the cache entry
  """
  refresh: Boolean! = false

  """
  measured in seconds
  """
  ttl: Int! = 60
) on QUERY

type AddBonusReturnType {
  bonus: BonusType!
  points: PointType!
}

"""
columns and relationships of "award"
"""
type Award {
  """
  An array relationship
  """
  awardEditions(
    """
    distinct select on columns
    """
    distinctOn: [AwardEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardEditionOrderBy!]

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): [AwardEdition!]!

  """
  An aggregate relationship
  """
  awardEditionsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AwardEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardEditionOrderBy!]

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): AwardEditionAggregate!
  awardId: bigint!
  awardName: String!
  awardType: String!
  awardValue: numeric!

  """
  An array relationship
  """
  bonuses(
    """
    distinct select on columns
    """
    distinctOn: [BonusesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BonusesOrderBy!]

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): [Bonuses!]!

  """
  An aggregate relationship
  """
  bonusesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [BonusesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BonusesOrderBy!]

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): BonusesAggregate!

  """
  An object relationship
  """
  category: Categories!
  categoryId: bigint!

  """
  An array relationship
  """
  chestAwards(
    """
    distinct select on columns
    """
    distinctOn: [ChestAwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestAwardOrderBy!]

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): [ChestAward!]!

  """
  An aggregate relationship
  """
  chestAwardsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestAwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestAwardOrderBy!]

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): ChestAwardAggregate!

  """
  An object relationship
  """
  file: Files
  imageFileId: bigint
  label: String!
  maxUsages: Int!
}

"""
aggregated selection of "award"
"""
type AwardAggregate {
  aggregate: AwardAggregateFields
  nodes: [Award!]!
}

input AwardAggregateBoolExp {
  count: awardAggregateBoolExpCount
}

"""
aggregate fields of "award"
"""
type AwardAggregateFields {
  avg: AwardAvgFields
  count(columns: [AwardSelectColumn!], distinct: Boolean): Int!
  max: AwardMaxFields
  min: AwardMinFields
  stddev: AwardStddevFields
  stddevPop: AwardStddevPopFields
  stddevSamp: AwardStddevSampFields
  sum: AwardSumFields
  varPop: AwardVarPopFields
  varSamp: AwardVarSampFields
  variance: AwardVarianceFields
}

"""
order by aggregate values of table "award"
"""
input AwardAggregateOrderBy {
  avg: AwardAvgOrderBy
  count: OrderBy
  max: AwardMaxOrderBy
  min: AwardMinOrderBy
  stddev: AwardStddevOrderBy
  stddevPop: AwardStddevPopOrderBy
  stddevSamp: AwardStddevSampOrderBy
  sum: AwardSumOrderBy
  varPop: AwardVarPopOrderBy
  varSamp: AwardVarSampOrderBy
  variance: AwardVarianceOrderBy
}

"""
input type for inserting array relation for remote table "award"
"""
input AwardArrRelInsertInput {
  data: [AwardInsertInput!]!

  """
  upsert condition
  """
  onConflict: AwardOnConflict
}

"""
aggregate avg on columns
"""
type AwardAvgFields {
  awardId: Float
  awardValue: Float
  categoryId: Float
  imageFileId: Float
  maxUsages: Float
}

"""
order by avg() on columns of table "award"
"""
input AwardAvgOrderBy {
  awardId: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  maxUsages: OrderBy
}

"""
Boolean expression to filter rows from the table "award". All fields are combined with a logical 'AND'.
"""
input AwardBoolExp {
  _and: [AwardBoolExp!]
  _not: AwardBoolExp
  _or: [AwardBoolExp!]
  awardEditions: AwardEditionBoolExp
  awardEditionsAggregate: AwardEditionAggregateBoolExp
  awardId: BigintComparisonExp
  awardName: StringComparisonExp
  awardType: StringComparisonExp
  awardValue: NumericComparisonExp
  bonuses: BonusesBoolExp
  bonusesAggregate: BonusesAggregateBoolExp
  category: CategoriesBoolExp
  categoryId: BigintComparisonExp
  chestAwards: ChestAwardBoolExp
  chestAwardsAggregate: ChestAwardAggregateBoolExp
  file: FilesBoolExp
  imageFileId: BigintComparisonExp
  label: StringComparisonExp
  maxUsages: IntComparisonExp
}

"""
unique or primary key constraints on table "award"
"""
enum AwardConstraint {
  """
  unique or primary key constraint on columns "award_id"
  """
  award_pkey
}

"""
columns and relationships of "award_edition"
"""
type AwardEdition {
  """
  An object relationship
  """
  award: Award!
  awardEditionId: bigint!
  awardId: bigint!

  """
  An object relationship
  """
  edition: Edition!
  editionId: bigint!
  label: String!
}

"""
aggregated selection of "award_edition"
"""
type AwardEditionAggregate {
  aggregate: AwardEditionAggregateFields
  nodes: [AwardEdition!]!
}

input AwardEditionAggregateBoolExp {
  count: awardEditionAggregateBoolExpCount
}

"""
aggregate fields of "award_edition"
"""
type AwardEditionAggregateFields {
  avg: AwardEditionAvgFields
  count(columns: [AwardEditionSelectColumn!], distinct: Boolean): Int!
  max: AwardEditionMaxFields
  min: AwardEditionMinFields
  stddev: AwardEditionStddevFields
  stddevPop: AwardEditionStddevPopFields
  stddevSamp: AwardEditionStddevSampFields
  sum: AwardEditionSumFields
  varPop: AwardEditionVarPopFields
  varSamp: AwardEditionVarSampFields
  variance: AwardEditionVarianceFields
}

"""
order by aggregate values of table "award_edition"
"""
input AwardEditionAggregateOrderBy {
  avg: AwardEditionAvgOrderBy
  count: OrderBy
  max: AwardEditionMaxOrderBy
  min: AwardEditionMinOrderBy
  stddev: AwardEditionStddevOrderBy
  stddevPop: AwardEditionStddevPopOrderBy
  stddevSamp: AwardEditionStddevSampOrderBy
  sum: AwardEditionSumOrderBy
  varPop: AwardEditionVarPopOrderBy
  varSamp: AwardEditionVarSampOrderBy
  variance: AwardEditionVarianceOrderBy
}

"""
input type for inserting array relation for remote table "award_edition"
"""
input AwardEditionArrRelInsertInput {
  data: [AwardEditionInsertInput!]!

  """
  upsert condition
  """
  onConflict: AwardEditionOnConflict
}

"""
aggregate avg on columns
"""
type AwardEditionAvgFields {
  awardEditionId: Float
  awardId: Float
  editionId: Float
}

"""
order by avg() on columns of table "award_edition"
"""
input AwardEditionAvgOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
}

"""
Boolean expression to filter rows from the table "award_edition". All fields are combined with a logical 'AND'.
"""
input AwardEditionBoolExp {
  _and: [AwardEditionBoolExp!]
  _not: AwardEditionBoolExp
  _or: [AwardEditionBoolExp!]
  award: AwardBoolExp
  awardEditionId: BigintComparisonExp
  awardId: BigintComparisonExp
  edition: EditionBoolExp
  editionId: BigintComparisonExp
  label: StringComparisonExp
}

"""
unique or primary key constraints on table "award_edition"
"""
enum AwardEditionConstraint {
  """
  unique or primary key constraint on columns "edition_id", "award_id"
  """
  award_edition_pkey
}

"""
input type for incrementing numeric columns in table "award_edition"
"""
input AwardEditionIncInput {
  awardEditionId: bigint
  awardId: bigint
  editionId: bigint
}

"""
input type for inserting data into table "award_edition"
"""
input AwardEditionInsertInput {
  award: AwardObjRelInsertInput
  awardEditionId: bigint
  awardId: bigint
  edition: EditionObjRelInsertInput
  editionId: bigint
  label: String
}

"""
aggregate max on columns
"""
type AwardEditionMaxFields {
  awardEditionId: bigint
  awardId: bigint
  editionId: bigint
  label: String
}

"""
order by max() on columns of table "award_edition"
"""
input AwardEditionMaxOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
  label: OrderBy
}

"""
aggregate min on columns
"""
type AwardEditionMinFields {
  awardEditionId: bigint
  awardId: bigint
  editionId: bigint
  label: String
}

"""
order by min() on columns of table "award_edition"
"""
input AwardEditionMinOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
  label: OrderBy
}

"""
response of any mutation on the table "award_edition"
"""
type AwardEditionMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [AwardEdition!]!
}

"""
on_conflict condition type for table "award_edition"
"""
input AwardEditionOnConflict {
  constraint: AwardEditionConstraint!
  updateColumns: [AwardEditionUpdateColumn!]! = []
  where: AwardEditionBoolExp
}

"""
Ordering options when selecting data from "award_edition".
"""
input AwardEditionOrderBy {
  award: AwardOrderBy
  awardEditionId: OrderBy
  awardId: OrderBy
  edition: EditionOrderBy
  editionId: OrderBy
  label: OrderBy
}

"""
primary key columns input for table: award_edition
"""
input AwardEditionPkColumnsInput {
  awardId: bigint!
  editionId: bigint!
}

"""
select columns of table "award_edition"
"""
enum AwardEditionSelectColumn {
  """
  column name
  """
  awardEditionId

  """
  column name
  """
  awardId

  """
  column name
  """
  editionId

  """
  column name
  """
  label
}

"""
input type for updating data in table "award_edition"
"""
input AwardEditionSetInput {
  awardEditionId: bigint
  awardId: bigint
  editionId: bigint
  label: String
}

"""
aggregate stddev on columns
"""
type AwardEditionStddevFields {
  awardEditionId: Float
  awardId: Float
  editionId: Float
}

"""
order by stddev() on columns of table "award_edition"
"""
input AwardEditionStddevOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type AwardEditionStddevPopFields {
  awardEditionId: Float
  awardId: Float
  editionId: Float
}

"""
order by stddevPop() on columns of table "award_edition"
"""
input AwardEditionStddevPopOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type AwardEditionStddevSampFields {
  awardEditionId: Float
  awardId: Float
  editionId: Float
}

"""
order by stddevSamp() on columns of table "award_edition"
"""
input AwardEditionStddevSampOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
}

"""
Streaming cursor of the table "award_edition"
"""
input AwardEditionStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: AwardEditionStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input AwardEditionStreamCursorValueInput {
  awardEditionId: bigint
  awardId: bigint
  editionId: bigint
  label: String
}

"""
aggregate sum on columns
"""
type AwardEditionSumFields {
  awardEditionId: bigint
  awardId: bigint
  editionId: bigint
}

"""
order by sum() on columns of table "award_edition"
"""
input AwardEditionSumOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
}

type AwardEditionType {
  award: AwardType!
  awardEditionId: ID!
  edition: EditionType!
  label: String!
}

"""
update columns of table "award_edition"
"""
enum AwardEditionUpdateColumn {
  """
  column name
  """
  awardEditionId

  """
  column name
  """
  awardId

  """
  column name
  """
  editionId

  """
  column name
  """
  label
}

input AwardEditionUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: AwardEditionIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: AwardEditionSetInput

  """
  filter the rows which have to be updated
  """
  where: AwardEditionBoolExp!
}

"""
aggregate varPop on columns
"""
type AwardEditionVarPopFields {
  awardEditionId: Float
  awardId: Float
  editionId: Float
}

"""
order by varPop() on columns of table "award_edition"
"""
input AwardEditionVarPopOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
}

"""
aggregate varSamp on columns
"""
type AwardEditionVarSampFields {
  awardEditionId: Float
  awardId: Float
  editionId: Float
}

"""
order by varSamp() on columns of table "award_edition"
"""
input AwardEditionVarSampOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
}

"""
aggregate variance on columns
"""
type AwardEditionVarianceFields {
  awardEditionId: Float
  awardId: Float
  editionId: Float
}

"""
order by variance() on columns of table "award_edition"
"""
input AwardEditionVarianceOrderBy {
  awardEditionId: OrderBy
  awardId: OrderBy
  editionId: OrderBy
}

"""
input type for incrementing numeric columns in table "award"
"""
input AwardIncInput {
  awardId: bigint
  awardValue: numeric
  categoryId: bigint
  imageFileId: bigint
  maxUsages: Int
}

"""
input type for inserting data into table "award"
"""
input AwardInsertInput {
  awardEditions: AwardEditionArrRelInsertInput
  awardId: bigint
  awardName: String
  awardType: String
  awardValue: numeric
  bonuses: BonusesArrRelInsertInput
  category: CategoriesObjRelInsertInput
  categoryId: bigint
  chestAwards: ChestAwardArrRelInsertInput
  file: FilesObjRelInsertInput
  imageFileId: bigint
  label: String
  maxUsages: Int
}

"""
aggregate max on columns
"""
type AwardMaxFields {
  awardId: bigint
  awardName: String
  awardType: String
  awardValue: numeric
  categoryId: bigint
  imageFileId: bigint
  label: String
  maxUsages: Int
}

"""
order by max() on columns of table "award"
"""
input AwardMaxOrderBy {
  awardId: OrderBy
  awardName: OrderBy
  awardType: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  maxUsages: OrderBy
}

"""
aggregate min on columns
"""
type AwardMinFields {
  awardId: bigint
  awardName: String
  awardType: String
  awardValue: numeric
  categoryId: bigint
  imageFileId: bigint
  label: String
  maxUsages: Int
}

"""
order by min() on columns of table "award"
"""
input AwardMinOrderBy {
  awardId: OrderBy
  awardName: OrderBy
  awardType: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  maxUsages: OrderBy
}

"""
response of any mutation on the table "award"
"""
type AwardMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Award!]!
}

"""
input type for inserting object relation for remote table "award"
"""
input AwardObjRelInsertInput {
  data: AwardInsertInput!

  """
  upsert condition
  """
  onConflict: AwardOnConflict
}

"""
on_conflict condition type for table "award"
"""
input AwardOnConflict {
  constraint: AwardConstraint!
  updateColumns: [AwardUpdateColumn!]! = []
  where: AwardBoolExp
}

"""
Ordering options when selecting data from "award".
"""
input AwardOrderBy {
  awardEditionsAggregate: AwardEditionAggregateOrderBy
  awardId: OrderBy
  awardName: OrderBy
  awardType: OrderBy
  awardValue: OrderBy
  bonusesAggregate: BonusesAggregateOrderBy
  category: CategoriesOrderBy
  categoryId: OrderBy
  chestAwardsAggregate: ChestAwardAggregateOrderBy
  file: FilesOrderBy
  imageFileId: OrderBy
  label: OrderBy
  maxUsages: OrderBy
}

"""
primary key columns input for table: award
"""
input AwardPkColumnsInput {
  awardId: bigint!
}

"""
select columns of table "award"
"""
enum AwardSelectColumn {
  """
  column name
  """
  awardId

  """
  column name
  """
  awardName

  """
  column name
  """
  awardType

  """
  column name
  """
  awardValue

  """
  column name
  """
  categoryId

  """
  column name
  """
  imageFileId

  """
  column name
  """
  label

  """
  column name
  """
  maxUsages
}

"""
input type for updating data in table "award"
"""
input AwardSetInput {
  awardId: bigint
  awardName: String
  awardType: String
  awardValue: numeric
  categoryId: bigint
  imageFileId: bigint
  label: String
  maxUsages: Int
}

"""
aggregate stddev on columns
"""
type AwardStddevFields {
  awardId: Float
  awardValue: Float
  categoryId: Float
  imageFileId: Float
  maxUsages: Float
}

"""
order by stddev() on columns of table "award"
"""
input AwardStddevOrderBy {
  awardId: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  maxUsages: OrderBy
}

"""
aggregate stddevPop on columns
"""
type AwardStddevPopFields {
  awardId: Float
  awardValue: Float
  categoryId: Float
  imageFileId: Float
  maxUsages: Float
}

"""
order by stddevPop() on columns of table "award"
"""
input AwardStddevPopOrderBy {
  awardId: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  maxUsages: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type AwardStddevSampFields {
  awardId: Float
  awardValue: Float
  categoryId: Float
  imageFileId: Float
  maxUsages: Float
}

"""
order by stddevSamp() on columns of table "award"
"""
input AwardStddevSampOrderBy {
  awardId: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  maxUsages: OrderBy
}

"""
Streaming cursor of the table "award"
"""
input AwardStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: AwardStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input AwardStreamCursorValueInput {
  awardId: bigint
  awardName: String
  awardType: String
  awardValue: numeric
  categoryId: bigint
  imageFileId: bigint
  label: String
  maxUsages: Int
}

"""
aggregate sum on columns
"""
type AwardSumFields {
  awardId: bigint
  awardValue: numeric
  categoryId: bigint
  imageFileId: bigint
  maxUsages: Int
}

"""
order by sum() on columns of table "award"
"""
input AwardSumOrderBy {
  awardId: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  maxUsages: OrderBy
}

type AwardType {
  awardEditions: [AwardEditionType]
  awardId: ID!
  awardName: String!
  awardType: AwardTypeType!
  awardValue: String!
  category: CategoryType
  imageFile: FileType
  label: String!
  maxUsages: Int!
}

enum AwardTypeType {
  ADDITIVE
  ADDITIVE_NEXT
  ADDITIVE_PREV
  MULTIPLICATIVE
}

"""
update columns of table "award"
"""
enum AwardUpdateColumn {
  """
  column name
  """
  awardId

  """
  column name
  """
  awardName

  """
  column name
  """
  awardType

  """
  column name
  """
  awardValue

  """
  column name
  """
  categoryId

  """
  column name
  """
  imageFileId

  """
  column name
  """
  label

  """
  column name
  """
  maxUsages
}

input AwardUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: AwardIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: AwardSetInput

  """
  filter the rows which have to be updated
  """
  where: AwardBoolExp!
}

"""
aggregate varPop on columns
"""
type AwardVarPopFields {
  awardId: Float
  awardValue: Float
  categoryId: Float
  imageFileId: Float
  maxUsages: Float
}

"""
order by varPop() on columns of table "award"
"""
input AwardVarPopOrderBy {
  awardId: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  maxUsages: OrderBy
}

"""
aggregate varSamp on columns
"""
type AwardVarSampFields {
  awardId: Float
  awardValue: Float
  categoryId: Float
  imageFileId: Float
  maxUsages: Float
}

"""
order by varSamp() on columns of table "award"
"""
input AwardVarSampOrderBy {
  awardId: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  maxUsages: OrderBy
}

"""
aggregate variance on columns
"""
type AwardVarianceFields {
  awardId: Float
  awardValue: Float
  categoryId: Float
  imageFileId: Float
  maxUsages: Float
}

"""
order by variance() on columns of table "award"
"""
input AwardVarianceOrderBy {
  awardId: OrderBy
  awardValue: OrderBy
  categoryId: OrderBy
  imageFileId: OrderBy
  maxUsages: OrderBy
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

type BonusType {
  award: AwardType!
  bonusId: ID!
  chestHistory: ChestHistoryType!
  createdAt: String!
  label: String!
  points: PointType!
  updatedAt: String!
}

"""
columns and relationships of "bonuses"
"""
type Bonuses {
  """
  An object relationship
  """
  award: Award!
  awardId: bigint!
  bonusId: bigint!

  """
  An object relationship
  """
  chestHistory: ChestHistory
  chestHistoryId: bigint
  createdAt: timestamp!
  label: String!

  """
  An object relationship
  """
  point: Points!
  pointsId: bigint!
  updatedAt: timestamp!
}

"""
aggregated selection of "bonuses"
"""
type BonusesAggregate {
  aggregate: BonusesAggregateFields
  nodes: [Bonuses!]!
}

input BonusesAggregateBoolExp {
  count: bonusesAggregateBoolExpCount
}

"""
aggregate fields of "bonuses"
"""
type BonusesAggregateFields {
  avg: BonusesAvgFields
  count(columns: [BonusesSelectColumn!], distinct: Boolean): Int!
  max: BonusesMaxFields
  min: BonusesMinFields
  stddev: BonusesStddevFields
  stddevPop: BonusesStddevPopFields
  stddevSamp: BonusesStddevSampFields
  sum: BonusesSumFields
  varPop: BonusesVarPopFields
  varSamp: BonusesVarSampFields
  variance: BonusesVarianceFields
}

"""
order by aggregate values of table "bonuses"
"""
input BonusesAggregateOrderBy {
  avg: BonusesAvgOrderBy
  count: OrderBy
  max: BonusesMaxOrderBy
  min: BonusesMinOrderBy
  stddev: BonusesStddevOrderBy
  stddevPop: BonusesStddevPopOrderBy
  stddevSamp: BonusesStddevSampOrderBy
  sum: BonusesSumOrderBy
  varPop: BonusesVarPopOrderBy
  varSamp: BonusesVarSampOrderBy
  variance: BonusesVarianceOrderBy
}

"""
input type for inserting array relation for remote table "bonuses"
"""
input BonusesArrRelInsertInput {
  data: [BonusesInsertInput!]!

  """
  upsert condition
  """
  onConflict: BonusesOnConflict
}

"""
aggregate avg on columns
"""
type BonusesAvgFields {
  awardId: Float
  bonusId: Float
  chestHistoryId: Float
  pointsId: Float
}

"""
order by avg() on columns of table "bonuses"
"""
input BonusesAvgOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  pointsId: OrderBy
}

"""
Boolean expression to filter rows from the table "bonuses". All fields are combined with a logical 'AND'.
"""
input BonusesBoolExp {
  _and: [BonusesBoolExp!]
  _not: BonusesBoolExp
  _or: [BonusesBoolExp!]
  award: AwardBoolExp
  awardId: BigintComparisonExp
  bonusId: BigintComparisonExp
  chestHistory: ChestHistoryBoolExp
  chestHistoryId: BigintComparisonExp
  createdAt: TimestampComparisonExp
  label: StringComparisonExp
  point: PointsBoolExp
  pointsId: BigintComparisonExp
  updatedAt: TimestampComparisonExp
}

"""
unique or primary key constraints on table "bonuses"
"""
enum BonusesConstraint {
  """
  unique or primary key constraint on columns "bonus_id"
  """
  bonuses_pkey

  """
  unique or primary key constraint on columns "chest_history_id"
  """
  uk_b9g0m7a50nte8ovqr4qmr2ush
}

"""
input type for incrementing numeric columns in table "bonuses"
"""
input BonusesIncInput {
  awardId: bigint
  bonusId: bigint
  chestHistoryId: bigint
  pointsId: bigint
}

"""
input type for inserting data into table "bonuses"
"""
input BonusesInsertInput {
  award: AwardObjRelInsertInput
  awardId: bigint
  bonusId: bigint
  chestHistory: ChestHistoryObjRelInsertInput
  chestHistoryId: bigint
  createdAt: timestamp
  label: String
  point: PointsObjRelInsertInput
  pointsId: bigint
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type BonusesMaxFields {
  awardId: bigint
  bonusId: bigint
  chestHistoryId: bigint
  createdAt: timestamp
  label: String
  pointsId: bigint
  updatedAt: timestamp
}

"""
order by max() on columns of table "bonuses"
"""
input BonusesMaxOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  createdAt: OrderBy
  label: OrderBy
  pointsId: OrderBy
  updatedAt: OrderBy
}

"""
aggregate min on columns
"""
type BonusesMinFields {
  awardId: bigint
  bonusId: bigint
  chestHistoryId: bigint
  createdAt: timestamp
  label: String
  pointsId: bigint
  updatedAt: timestamp
}

"""
order by min() on columns of table "bonuses"
"""
input BonusesMinOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  createdAt: OrderBy
  label: OrderBy
  pointsId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "bonuses"
"""
type BonusesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Bonuses!]!
}

"""
input type for inserting object relation for remote table "bonuses"
"""
input BonusesObjRelInsertInput {
  data: BonusesInsertInput!

  """
  upsert condition
  """
  onConflict: BonusesOnConflict
}

"""
on_conflict condition type for table "bonuses"
"""
input BonusesOnConflict {
  constraint: BonusesConstraint!
  updateColumns: [BonusesUpdateColumn!]! = []
  where: BonusesBoolExp
}

"""
Ordering options when selecting data from "bonuses".
"""
input BonusesOrderBy {
  award: AwardOrderBy
  awardId: OrderBy
  bonusId: OrderBy
  chestHistory: ChestHistoryOrderBy
  chestHistoryId: OrderBy
  createdAt: OrderBy
  label: OrderBy
  point: PointsOrderBy
  pointsId: OrderBy
  updatedAt: OrderBy
}

"""
primary key columns input for table: bonuses
"""
input BonusesPkColumnsInput {
  bonusId: bigint!
}

"""
select columns of table "bonuses"
"""
enum BonusesSelectColumn {
  """
  column name
  """
  awardId

  """
  column name
  """
  bonusId

  """
  column name
  """
  chestHistoryId

  """
  column name
  """
  createdAt

  """
  column name
  """
  label

  """
  column name
  """
  pointsId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "bonuses"
"""
input BonusesSetInput {
  awardId: bigint
  bonusId: bigint
  chestHistoryId: bigint
  createdAt: timestamp
  label: String
  pointsId: bigint
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type BonusesStddevFields {
  awardId: Float
  bonusId: Float
  chestHistoryId: Float
  pointsId: Float
}

"""
order by stddev() on columns of table "bonuses"
"""
input BonusesStddevOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  pointsId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type BonusesStddevPopFields {
  awardId: Float
  bonusId: Float
  chestHistoryId: Float
  pointsId: Float
}

"""
order by stddevPop() on columns of table "bonuses"
"""
input BonusesStddevPopOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  pointsId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type BonusesStddevSampFields {
  awardId: Float
  bonusId: Float
  chestHistoryId: Float
  pointsId: Float
}

"""
order by stddevSamp() on columns of table "bonuses"
"""
input BonusesStddevSampOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  pointsId: OrderBy
}

"""
Streaming cursor of the table "bonuses"
"""
input BonusesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: BonusesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input BonusesStreamCursorValueInput {
  awardId: bigint
  bonusId: bigint
  chestHistoryId: bigint
  createdAt: timestamp
  label: String
  pointsId: bigint
  updatedAt: timestamp
}

"""
aggregate sum on columns
"""
type BonusesSumFields {
  awardId: bigint
  bonusId: bigint
  chestHistoryId: bigint
  pointsId: bigint
}

"""
order by sum() on columns of table "bonuses"
"""
input BonusesSumOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  pointsId: OrderBy
}

"""
update columns of table "bonuses"
"""
enum BonusesUpdateColumn {
  """
  column name
  """
  awardId

  """
  column name
  """
  bonusId

  """
  column name
  """
  chestHistoryId

  """
  column name
  """
  createdAt

  """
  column name
  """
  label

  """
  column name
  """
  pointsId

  """
  column name
  """
  updatedAt
}

input BonusesUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: BonusesIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: BonusesSetInput

  """
  filter the rows which have to be updated
  """
  where: BonusesBoolExp!
}

"""
aggregate varPop on columns
"""
type BonusesVarPopFields {
  awardId: Float
  bonusId: Float
  chestHistoryId: Float
  pointsId: Float
}

"""
order by varPop() on columns of table "bonuses"
"""
input BonusesVarPopOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  pointsId: OrderBy
}

"""
aggregate varSamp on columns
"""
type BonusesVarSampFields {
  awardId: Float
  bonusId: Float
  chestHistoryId: Float
  pointsId: Float
}

"""
order by varSamp() on columns of table "bonuses"
"""
input BonusesVarSampOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  pointsId: OrderBy
}

"""
aggregate variance on columns
"""
type BonusesVarianceFields {
  awardId: Float
  bonusId: Float
  chestHistoryId: Float
  pointsId: Float
}

"""
order by variance() on columns of table "bonuses"
"""
input BonusesVarianceOrderBy {
  awardId: OrderBy
  bonusId: OrderBy
  chestHistoryId: OrderBy
  pointsId: OrderBy
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "categories"
"""
type Categories {
  """
  An array relationship
  """
  awards(
    """
    distinct select on columns
    """
    distinctOn: [AwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardOrderBy!]

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): [Award!]!

  """
  An aggregate relationship
  """
  awardsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardOrderBy!]

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): AwardAggregate!
  canAddPoints: Boolean!

  """
  An array relationship
  """
  categoryEditions(
    """
    distinct select on columns
    """
    distinctOn: [CategoryEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoryEditionOrderBy!]

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): [CategoryEdition!]!

  """
  An aggregate relationship
  """
  categoryEditionsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [CategoryEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoryEditionOrderBy!]

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): CategoryEditionAggregate!
  categoryId: bigint!
  categoryName: String!
  label: String!

  """
  An array relationship
  """
  subcategories(
    """
    distinct select on columns
    """
    distinctOn: [SubcategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SubcategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): [Subcategories!]!

  """
  An aggregate relationship
  """
  subcategoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SubcategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SubcategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): SubcategoriesAggregate!
}

"""
aggregated selection of "categories"
"""
type CategoriesAggregate {
  aggregate: CategoriesAggregateFields
  nodes: [Categories!]!
}

"""
aggregate fields of "categories"
"""
type CategoriesAggregateFields {
  avg: CategoriesAvgFields
  count(columns: [CategoriesSelectColumn!], distinct: Boolean): Int!
  max: CategoriesMaxFields
  min: CategoriesMinFields
  stddev: CategoriesStddevFields
  stddevPop: CategoriesStddevPopFields
  stddevSamp: CategoriesStddevSampFields
  sum: CategoriesSumFields
  varPop: CategoriesVarPopFields
  varSamp: CategoriesVarSampFields
  variance: CategoriesVarianceFields
}

"""
aggregate avg on columns
"""
type CategoriesAvgFields {
  categoryId: Float
}

"""
Boolean expression to filter rows from the table "categories". All fields are combined with a logical 'AND'.
"""
input CategoriesBoolExp {
  _and: [CategoriesBoolExp!]
  _not: CategoriesBoolExp
  _or: [CategoriesBoolExp!]
  awards: AwardBoolExp
  awardsAggregate: AwardAggregateBoolExp
  canAddPoints: BooleanComparisonExp
  categoryEditions: CategoryEditionBoolExp
  categoryEditionsAggregate: CategoryEditionAggregateBoolExp
  categoryId: BigintComparisonExp
  categoryName: StringComparisonExp
  label: StringComparisonExp
  subcategories: SubcategoriesBoolExp
  subcategoriesAggregate: SubcategoriesAggregateBoolExp
}

"""
unique or primary key constraints on table "categories"
"""
enum CategoriesConstraint {
  """
  unique or primary key constraint on columns "category_id"
  """
  categories_pkey
}

"""
input type for incrementing numeric columns in table "categories"
"""
input CategoriesIncInput {
  categoryId: bigint
}

"""
input type for inserting data into table "categories"
"""
input CategoriesInsertInput {
  awards: AwardArrRelInsertInput
  canAddPoints: Boolean
  categoryEditions: CategoryEditionArrRelInsertInput
  categoryId: bigint
  categoryName: String
  label: String
  subcategories: SubcategoriesArrRelInsertInput
}

"""
aggregate max on columns
"""
type CategoriesMaxFields {
  categoryId: bigint
  categoryName: String
  label: String
}

"""
aggregate min on columns
"""
type CategoriesMinFields {
  categoryId: bigint
  categoryName: String
  label: String
}

"""
response of any mutation on the table "categories"
"""
type CategoriesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Categories!]!
}

"""
input type for inserting object relation for remote table "categories"
"""
input CategoriesObjRelInsertInput {
  data: CategoriesInsertInput!

  """
  upsert condition
  """
  onConflict: CategoriesOnConflict
}

"""
on_conflict condition type for table "categories"
"""
input CategoriesOnConflict {
  constraint: CategoriesConstraint!
  updateColumns: [CategoriesUpdateColumn!]! = []
  where: CategoriesBoolExp
}

"""
Ordering options when selecting data from "categories".
"""
input CategoriesOrderBy {
  awardsAggregate: AwardAggregateOrderBy
  canAddPoints: OrderBy
  categoryEditionsAggregate: CategoryEditionAggregateOrderBy
  categoryId: OrderBy
  categoryName: OrderBy
  label: OrderBy
  subcategoriesAggregate: SubcategoriesAggregateOrderBy
}

"""
primary key columns input for table: categories
"""
input CategoriesPkColumnsInput {
  categoryId: bigint!
}

"""
select columns of table "categories"
"""
enum CategoriesSelectColumn {
  """
  column name
  """
  canAddPoints

  """
  column name
  """
  categoryId

  """
  column name
  """
  categoryName

  """
  column name
  """
  label
}

"""
input type for updating data in table "categories"
"""
input CategoriesSetInput {
  canAddPoints: Boolean
  categoryId: bigint
  categoryName: String
  label: String
}

"""
aggregate stddev on columns
"""
type CategoriesStddevFields {
  categoryId: Float
}

"""
aggregate stddevPop on columns
"""
type CategoriesStddevPopFields {
  categoryId: Float
}

"""
aggregate stddevSamp on columns
"""
type CategoriesStddevSampFields {
  categoryId: Float
}

"""
Streaming cursor of the table "categories"
"""
input CategoriesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: CategoriesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input CategoriesStreamCursorValueInput {
  canAddPoints: Boolean
  categoryId: bigint
  categoryName: String
  label: String
}

"""
aggregate sum on columns
"""
type CategoriesSumFields {
  categoryId: bigint
}

"""
update columns of table "categories"
"""
enum CategoriesUpdateColumn {
  """
  column name
  """
  canAddPoints

  """
  column name
  """
  categoryId

  """
  column name
  """
  categoryName

  """
  column name
  """
  label
}

input CategoriesUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: CategoriesIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: CategoriesSetInput

  """
  filter the rows which have to be updated
  """
  where: CategoriesBoolExp!
}

"""
aggregate varPop on columns
"""
type CategoriesVarPopFields {
  categoryId: Float
}

"""
aggregate varSamp on columns
"""
type CategoriesVarSampFields {
  categoryId: Float
}

"""
aggregate variance on columns
"""
type CategoriesVarianceFields {
  categoryId: Float
}

type CategoryAggregate {
  category: CategoryType!
  sumOfAll: Float!
  sumOfBonuses: Float!
  sumOfPurePoints: Float!
}

"""
columns and relationships of "category_edition"
"""
type CategoryEdition {
  """
  An object relationship
  """
  category: Categories!
  categoryEditionId: bigint!
  categoryId: bigint!

  """
  An object relationship
  """
  edition: Edition!
  editionId: bigint!
  label: String!
}

"""
aggregated selection of "category_edition"
"""
type CategoryEditionAggregate {
  aggregate: CategoryEditionAggregateFields
  nodes: [CategoryEdition!]!
}

input CategoryEditionAggregateBoolExp {
  count: categoryEditionAggregateBoolExpCount
}

"""
aggregate fields of "category_edition"
"""
type CategoryEditionAggregateFields {
  avg: CategoryEditionAvgFields
  count(columns: [CategoryEditionSelectColumn!], distinct: Boolean): Int!
  max: CategoryEditionMaxFields
  min: CategoryEditionMinFields
  stddev: CategoryEditionStddevFields
  stddevPop: CategoryEditionStddevPopFields
  stddevSamp: CategoryEditionStddevSampFields
  sum: CategoryEditionSumFields
  varPop: CategoryEditionVarPopFields
  varSamp: CategoryEditionVarSampFields
  variance: CategoryEditionVarianceFields
}

"""
order by aggregate values of table "category_edition"
"""
input CategoryEditionAggregateOrderBy {
  avg: CategoryEditionAvgOrderBy
  count: OrderBy
  max: CategoryEditionMaxOrderBy
  min: CategoryEditionMinOrderBy
  stddev: CategoryEditionStddevOrderBy
  stddevPop: CategoryEditionStddevPopOrderBy
  stddevSamp: CategoryEditionStddevSampOrderBy
  sum: CategoryEditionSumOrderBy
  varPop: CategoryEditionVarPopOrderBy
  varSamp: CategoryEditionVarSampOrderBy
  variance: CategoryEditionVarianceOrderBy
}

"""
input type for inserting array relation for remote table "category_edition"
"""
input CategoryEditionArrRelInsertInput {
  data: [CategoryEditionInsertInput!]!

  """
  upsert condition
  """
  onConflict: CategoryEditionOnConflict
}

"""
aggregate avg on columns
"""
type CategoryEditionAvgFields {
  categoryEditionId: Float
  categoryId: Float
  editionId: Float
}

"""
order by avg() on columns of table "category_edition"
"""
input CategoryEditionAvgOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
}

"""
Boolean expression to filter rows from the table "category_edition". All fields are combined with a logical 'AND'.
"""
input CategoryEditionBoolExp {
  _and: [CategoryEditionBoolExp!]
  _not: CategoryEditionBoolExp
  _or: [CategoryEditionBoolExp!]
  category: CategoriesBoolExp
  categoryEditionId: BigintComparisonExp
  categoryId: BigintComparisonExp
  edition: EditionBoolExp
  editionId: BigintComparisonExp
  label: StringComparisonExp
}

"""
unique or primary key constraints on table "category_edition"
"""
enum CategoryEditionConstraint {
  """
  unique or primary key constraint on columns "edition_id", "category_id"
  """
  category_edition_pkey

  """
  unique or primary key constraint on columns "edition_id", "category_id"
  """
  unique_category_edition
}

"""
input type for incrementing numeric columns in table "category_edition"
"""
input CategoryEditionIncInput {
  categoryEditionId: bigint
  categoryId: bigint
  editionId: bigint
}

"""
input type for inserting data into table "category_edition"
"""
input CategoryEditionInsertInput {
  category: CategoriesObjRelInsertInput
  categoryEditionId: bigint
  categoryId: bigint
  edition: EditionObjRelInsertInput
  editionId: bigint
  label: String
}

"""
aggregate max on columns
"""
type CategoryEditionMaxFields {
  categoryEditionId: bigint
  categoryId: bigint
  editionId: bigint
  label: String
}

"""
order by max() on columns of table "category_edition"
"""
input CategoryEditionMaxOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
  label: OrderBy
}

"""
aggregate min on columns
"""
type CategoryEditionMinFields {
  categoryEditionId: bigint
  categoryId: bigint
  editionId: bigint
  label: String
}

"""
order by min() on columns of table "category_edition"
"""
input CategoryEditionMinOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
  label: OrderBy
}

"""
response of any mutation on the table "category_edition"
"""
type CategoryEditionMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [CategoryEdition!]!
}

"""
on_conflict condition type for table "category_edition"
"""
input CategoryEditionOnConflict {
  constraint: CategoryEditionConstraint!
  updateColumns: [CategoryEditionUpdateColumn!]! = []
  where: CategoryEditionBoolExp
}

"""
Ordering options when selecting data from "category_edition".
"""
input CategoryEditionOrderBy {
  category: CategoriesOrderBy
  categoryEditionId: OrderBy
  categoryId: OrderBy
  edition: EditionOrderBy
  editionId: OrderBy
  label: OrderBy
}

"""
primary key columns input for table: category_edition
"""
input CategoryEditionPkColumnsInput {
  categoryId: bigint!
  editionId: bigint!
}

"""
select columns of table "category_edition"
"""
enum CategoryEditionSelectColumn {
  """
  column name
  """
  categoryEditionId

  """
  column name
  """
  categoryId

  """
  column name
  """
  editionId

  """
  column name
  """
  label
}

"""
input type for updating data in table "category_edition"
"""
input CategoryEditionSetInput {
  categoryEditionId: bigint
  categoryId: bigint
  editionId: bigint
  label: String
}

"""
aggregate stddev on columns
"""
type CategoryEditionStddevFields {
  categoryEditionId: Float
  categoryId: Float
  editionId: Float
}

"""
order by stddev() on columns of table "category_edition"
"""
input CategoryEditionStddevOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type CategoryEditionStddevPopFields {
  categoryEditionId: Float
  categoryId: Float
  editionId: Float
}

"""
order by stddevPop() on columns of table "category_edition"
"""
input CategoryEditionStddevPopOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type CategoryEditionStddevSampFields {
  categoryEditionId: Float
  categoryId: Float
  editionId: Float
}

"""
order by stddevSamp() on columns of table "category_edition"
"""
input CategoryEditionStddevSampOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
}

"""
Streaming cursor of the table "category_edition"
"""
input CategoryEditionStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: CategoryEditionStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input CategoryEditionStreamCursorValueInput {
  categoryEditionId: bigint
  categoryId: bigint
  editionId: bigint
  label: String
}

"""
aggregate sum on columns
"""
type CategoryEditionSumFields {
  categoryEditionId: bigint
  categoryId: bigint
  editionId: bigint
}

"""
order by sum() on columns of table "category_edition"
"""
input CategoryEditionSumOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
}

type CategoryEditionType {
  category: CategoryType!
  categoryEditionId: ID!
  edition: EditionType!
  label: String!
}

"""
update columns of table "category_edition"
"""
enum CategoryEditionUpdateColumn {
  """
  column name
  """
  categoryEditionId

  """
  column name
  """
  categoryId

  """
  column name
  """
  editionId

  """
  column name
  """
  label
}

input CategoryEditionUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: CategoryEditionIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: CategoryEditionSetInput

  """
  filter the rows which have to be updated
  """
  where: CategoryEditionBoolExp!
}

"""
aggregate varPop on columns
"""
type CategoryEditionVarPopFields {
  categoryEditionId: Float
  categoryId: Float
  editionId: Float
}

"""
order by varPop() on columns of table "category_edition"
"""
input CategoryEditionVarPopOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
}

"""
aggregate varSamp on columns
"""
type CategoryEditionVarSampFields {
  categoryEditionId: Float
  categoryId: Float
  editionId: Float
}

"""
order by varSamp() on columns of table "category_edition"
"""
input CategoryEditionVarSampOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
}

"""
aggregate variance on columns
"""
type CategoryEditionVarianceFields {
  categoryEditionId: Float
  categoryId: Float
  editionId: Float
}

"""
order by variance() on columns of table "category_edition"
"""
input CategoryEditionVarianceOrderBy {
  categoryEditionId: OrderBy
  categoryId: OrderBy
  editionId: OrderBy
}

type CategoryPointsSumType {
  category: CategoryType!
  maxPoints: Float!
  sumOfAll: Float!
  sumOfBonuses: Float!
  sumOfPurePoints: Float!
}

type CategoryPointsType {
  aggregate: CategoryAggregate!
  category: CategoryType!
  subcategoryPoints: [SubcategoryPointsType!]!
}

type CategoryType {
  canAddPoints: Boolean!
  categoryEdition: [CategoryEditionType]!
  categoryId: ID!
  categoryName: String!
  label: String!
}

"""
columns and relationships of "chest_award"
"""
type ChestAward {
  """
  An object relationship
  """
  award: Award!
  awardId: bigint!

  """
  An object relationship
  """
  chest: Chests!
  chestAwardId: bigint!
  chestId: bigint!
  label: String!
}

"""
aggregated selection of "chest_award"
"""
type ChestAwardAggregate {
  aggregate: ChestAwardAggregateFields
  nodes: [ChestAward!]!
}

input ChestAwardAggregateBoolExp {
  count: chestAwardAggregateBoolExpCount
}

"""
aggregate fields of "chest_award"
"""
type ChestAwardAggregateFields {
  avg: ChestAwardAvgFields
  count(columns: [ChestAwardSelectColumn!], distinct: Boolean): Int!
  max: ChestAwardMaxFields
  min: ChestAwardMinFields
  stddev: ChestAwardStddevFields
  stddevPop: ChestAwardStddevPopFields
  stddevSamp: ChestAwardStddevSampFields
  sum: ChestAwardSumFields
  varPop: ChestAwardVarPopFields
  varSamp: ChestAwardVarSampFields
  variance: ChestAwardVarianceFields
}

"""
order by aggregate values of table "chest_award"
"""
input ChestAwardAggregateOrderBy {
  avg: ChestAwardAvgOrderBy
  count: OrderBy
  max: ChestAwardMaxOrderBy
  min: ChestAwardMinOrderBy
  stddev: ChestAwardStddevOrderBy
  stddevPop: ChestAwardStddevPopOrderBy
  stddevSamp: ChestAwardStddevSampOrderBy
  sum: ChestAwardSumOrderBy
  varPop: ChestAwardVarPopOrderBy
  varSamp: ChestAwardVarSampOrderBy
  variance: ChestAwardVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chest_award"
"""
input ChestAwardArrRelInsertInput {
  data: [ChestAwardInsertInput!]!

  """
  upsert condition
  """
  onConflict: ChestAwardOnConflict
}

"""
aggregate avg on columns
"""
type ChestAwardAvgFields {
  awardId: Float
  chestAwardId: Float
  chestId: Float
}

"""
order by avg() on columns of table "chest_award"
"""
input ChestAwardAvgOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
}

"""
Boolean expression to filter rows from the table "chest_award". All fields are combined with a logical 'AND'.
"""
input ChestAwardBoolExp {
  _and: [ChestAwardBoolExp!]
  _not: ChestAwardBoolExp
  _or: [ChestAwardBoolExp!]
  award: AwardBoolExp
  awardId: BigintComparisonExp
  chest: ChestsBoolExp
  chestAwardId: BigintComparisonExp
  chestId: BigintComparisonExp
  label: StringComparisonExp
}

"""
unique or primary key constraints on table "chest_award"
"""
enum ChestAwardConstraint {
  """
  unique or primary key constraint on columns "chest_award_id"
  """
  chest_award_pkey
}

"""
input type for incrementing numeric columns in table "chest_award"
"""
input ChestAwardIncInput {
  awardId: bigint
  chestAwardId: bigint
  chestId: bigint
}

"""
input type for inserting data into table "chest_award"
"""
input ChestAwardInsertInput {
  award: AwardObjRelInsertInput
  awardId: bigint
  chest: ChestsObjRelInsertInput
  chestAwardId: bigint
  chestId: bigint
  label: String
}

"""
aggregate max on columns
"""
type ChestAwardMaxFields {
  awardId: bigint
  chestAwardId: bigint
  chestId: bigint
  label: String
}

"""
order by max() on columns of table "chest_award"
"""
input ChestAwardMaxOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
  label: OrderBy
}

"""
aggregate min on columns
"""
type ChestAwardMinFields {
  awardId: bigint
  chestAwardId: bigint
  chestId: bigint
  label: String
}

"""
order by min() on columns of table "chest_award"
"""
input ChestAwardMinOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
  label: OrderBy
}

"""
response of any mutation on the table "chest_award"
"""
type ChestAwardMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ChestAward!]!
}

"""
on_conflict condition type for table "chest_award"
"""
input ChestAwardOnConflict {
  constraint: ChestAwardConstraint!
  updateColumns: [ChestAwardUpdateColumn!]! = []
  where: ChestAwardBoolExp
}

"""
Ordering options when selecting data from "chest_award".
"""
input ChestAwardOrderBy {
  award: AwardOrderBy
  awardId: OrderBy
  chest: ChestsOrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
  label: OrderBy
}

"""
primary key columns input for table: chest_award
"""
input ChestAwardPkColumnsInput {
  chestAwardId: bigint!
}

"""
select columns of table "chest_award"
"""
enum ChestAwardSelectColumn {
  """
  column name
  """
  awardId

  """
  column name
  """
  chestAwardId

  """
  column name
  """
  chestId

  """
  column name
  """
  label
}

"""
input type for updating data in table "chest_award"
"""
input ChestAwardSetInput {
  awardId: bigint
  chestAwardId: bigint
  chestId: bigint
  label: String
}

"""
aggregate stddev on columns
"""
type ChestAwardStddevFields {
  awardId: Float
  chestAwardId: Float
  chestId: Float
}

"""
order by stddev() on columns of table "chest_award"
"""
input ChestAwardStddevOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type ChestAwardStddevPopFields {
  awardId: Float
  chestAwardId: Float
  chestId: Float
}

"""
order by stddevPop() on columns of table "chest_award"
"""
input ChestAwardStddevPopOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type ChestAwardStddevSampFields {
  awardId: Float
  chestAwardId: Float
  chestId: Float
}

"""
order by stddevSamp() on columns of table "chest_award"
"""
input ChestAwardStddevSampOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
}

"""
Streaming cursor of the table "chest_award"
"""
input ChestAwardStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: ChestAwardStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input ChestAwardStreamCursorValueInput {
  awardId: bigint
  chestAwardId: bigint
  chestId: bigint
  label: String
}

"""
aggregate sum on columns
"""
type ChestAwardSumFields {
  awardId: bigint
  chestAwardId: bigint
  chestId: bigint
}

"""
order by sum() on columns of table "chest_award"
"""
input ChestAwardSumOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
}

type ChestAwardType {
  award: AwardType!
  chest: ChestType!
  chestAwardId: ID!
  label: String!
}

"""
update columns of table "chest_award"
"""
enum ChestAwardUpdateColumn {
  """
  column name
  """
  awardId

  """
  column name
  """
  chestAwardId

  """
  column name
  """
  chestId

  """
  column name
  """
  label
}

input ChestAwardUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ChestAwardIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ChestAwardSetInput

  """
  filter the rows which have to be updated
  """
  where: ChestAwardBoolExp!
}

"""
aggregate varPop on columns
"""
type ChestAwardVarPopFields {
  awardId: Float
  chestAwardId: Float
  chestId: Float
}

"""
order by varPop() on columns of table "chest_award"
"""
input ChestAwardVarPopOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
}

"""
aggregate varSamp on columns
"""
type ChestAwardVarSampFields {
  awardId: Float
  chestAwardId: Float
  chestId: Float
}

"""
order by varSamp() on columns of table "chest_award"
"""
input ChestAwardVarSampOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
}

"""
aggregate variance on columns
"""
type ChestAwardVarianceFields {
  awardId: Float
  chestAwardId: Float
  chestId: Float
}

"""
order by variance() on columns of table "chest_award"
"""
input ChestAwardVarianceOrderBy {
  awardId: OrderBy
  chestAwardId: OrderBy
  chestId: OrderBy
}

"""
columns and relationships of "chest_history"
"""
type ChestHistory {
  """
  An object relationship
  """
  bonus: Bonuses

  """
  An object relationship
  """
  chest: Chests!
  chestHistoryId: bigint!
  chestId: bigint!
  createdAt: timestamp!
  label: String!
  opened: Boolean!

  """
  An object relationship
  """
  subcategory: Subcategories!
  subcategoryId: bigint!
  teacherId: bigint!
  updatedAt: timestamp!

  """
  An object relationship
  """
  user: Users!

  """
  An object relationship
  """
  userByTeacherId: Users!
  userId: bigint!
}

"""
aggregated selection of "chest_history"
"""
type ChestHistoryAggregate {
  aggregate: ChestHistoryAggregateFields
  nodes: [ChestHistory!]!
}

input ChestHistoryAggregateBoolExp {
  bool_and: chestHistoryAggregateBoolExpBool_and
  bool_or: chestHistoryAggregateBoolExpBool_or
  count: chestHistoryAggregateBoolExpCount
}

"""
aggregate fields of "chest_history"
"""
type ChestHistoryAggregateFields {
  avg: ChestHistoryAvgFields
  count(columns: [ChestHistorySelectColumn!], distinct: Boolean): Int!
  max: ChestHistoryMaxFields
  min: ChestHistoryMinFields
  stddev: ChestHistoryStddevFields
  stddevPop: ChestHistoryStddevPopFields
  stddevSamp: ChestHistoryStddevSampFields
  sum: ChestHistorySumFields
  varPop: ChestHistoryVarPopFields
  varSamp: ChestHistoryVarSampFields
  variance: ChestHistoryVarianceFields
}

"""
order by aggregate values of table "chest_history"
"""
input ChestHistoryAggregateOrderBy {
  avg: ChestHistoryAvgOrderBy
  count: OrderBy
  max: ChestHistoryMaxOrderBy
  min: ChestHistoryMinOrderBy
  stddev: ChestHistoryStddevOrderBy
  stddevPop: ChestHistoryStddevPopOrderBy
  stddevSamp: ChestHistoryStddevSampOrderBy
  sum: ChestHistorySumOrderBy
  varPop: ChestHistoryVarPopOrderBy
  varSamp: ChestHistoryVarSampOrderBy
  variance: ChestHistoryVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chest_history"
"""
input ChestHistoryArrRelInsertInput {
  data: [ChestHistoryInsertInput!]!

  """
  upsert condition
  """
  onConflict: ChestHistoryOnConflict
}

"""
aggregate avg on columns
"""
type ChestHistoryAvgFields {
  chestHistoryId: Float
  chestId: Float
  subcategoryId: Float
  teacherId: Float
  userId: Float
}

"""
order by avg() on columns of table "chest_history"
"""
input ChestHistoryAvgOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  userId: OrderBy
}

"""
Boolean expression to filter rows from the table "chest_history". All fields are combined with a logical 'AND'.
"""
input ChestHistoryBoolExp {
  _and: [ChestHistoryBoolExp!]
  _not: ChestHistoryBoolExp
  _or: [ChestHistoryBoolExp!]
  bonus: BonusesBoolExp
  chest: ChestsBoolExp
  chestHistoryId: BigintComparisonExp
  chestId: BigintComparisonExp
  createdAt: TimestampComparisonExp
  label: StringComparisonExp
  opened: BooleanComparisonExp
  subcategory: SubcategoriesBoolExp
  subcategoryId: BigintComparisonExp
  teacherId: BigintComparisonExp
  updatedAt: TimestampComparisonExp
  user: UsersBoolExp
  userByTeacherId: UsersBoolExp
  userId: BigintComparisonExp
}

"""
unique or primary key constraints on table "chest_history"
"""
enum ChestHistoryConstraint {
  """
  unique or primary key constraint on columns "chest_history_id"
  """
  chest_history_pkey
}

"""
input type for incrementing numeric columns in table "chest_history"
"""
input ChestHistoryIncInput {
  chestHistoryId: bigint
  chestId: bigint
  subcategoryId: bigint
  teacherId: bigint
  userId: bigint
}

"""
input type for inserting data into table "chest_history"
"""
input ChestHistoryInsertInput {
  bonus: BonusesObjRelInsertInput
  chest: ChestsObjRelInsertInput
  chestHistoryId: bigint
  chestId: bigint
  createdAt: timestamp
  label: String
  opened: Boolean
  subcategory: SubcategoriesObjRelInsertInput
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  user: UsersObjRelInsertInput
  userByTeacherId: UsersObjRelInsertInput
  userId: bigint
}

"""
aggregate max on columns
"""
type ChestHistoryMaxFields {
  chestHistoryId: bigint
  chestId: bigint
  createdAt: timestamp
  label: String
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  userId: bigint
}

"""
order by max() on columns of table "chest_history"
"""
input ChestHistoryMaxOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  createdAt: OrderBy
  label: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
aggregate min on columns
"""
type ChestHistoryMinFields {
  chestHistoryId: bigint
  chestId: bigint
  createdAt: timestamp
  label: String
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  userId: bigint
}

"""
order by min() on columns of table "chest_history"
"""
input ChestHistoryMinOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  createdAt: OrderBy
  label: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "chest_history"
"""
type ChestHistoryMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ChestHistory!]!
}

"""
input type for inserting object relation for remote table "chest_history"
"""
input ChestHistoryObjRelInsertInput {
  data: ChestHistoryInsertInput!

  """
  upsert condition
  """
  onConflict: ChestHistoryOnConflict
}

"""
on_conflict condition type for table "chest_history"
"""
input ChestHistoryOnConflict {
  constraint: ChestHistoryConstraint!
  updateColumns: [ChestHistoryUpdateColumn!]! = []
  where: ChestHistoryBoolExp
}

"""
Ordering options when selecting data from "chest_history".
"""
input ChestHistoryOrderBy {
  bonus: BonusesOrderBy
  chest: ChestsOrderBy
  chestHistoryId: OrderBy
  chestId: OrderBy
  createdAt: OrderBy
  label: OrderBy
  opened: OrderBy
  subcategory: SubcategoriesOrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  user: UsersOrderBy
  userByTeacherId: UsersOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: chest_history
"""
input ChestHistoryPkColumnsInput {
  chestHistoryId: bigint!
}

"""
select columns of table "chest_history"
"""
enum ChestHistorySelectColumn {
  """
  column name
  """
  chestHistoryId

  """
  column name
  """
  chestId

  """
  column name
  """
  createdAt

  """
  column name
  """
  label

  """
  column name
  """
  opened

  """
  column name
  """
  subcategoryId

  """
  column name
  """
  teacherId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  userId
}

"""
select "chestHistoryAggregateBoolExpBool_andArgumentsColumns" columns of table "chest_history"
"""
enum ChestHistorySelectColumnChestHistoryAggregateBoolExpBool_andArgumentsColumns {
  """
  column name
  """
  opened
}

"""
select "chestHistoryAggregateBoolExpBool_orArgumentsColumns" columns of table "chest_history"
"""
enum ChestHistorySelectColumnChestHistoryAggregateBoolExpBool_orArgumentsColumns {
  """
  column name
  """
  opened
}

"""
input type for updating data in table "chest_history"
"""
input ChestHistorySetInput {
  chestHistoryId: bigint
  chestId: bigint
  createdAt: timestamp
  label: String
  opened: Boolean
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  userId: bigint
}

"""
aggregate stddev on columns
"""
type ChestHistoryStddevFields {
  chestHistoryId: Float
  chestId: Float
  subcategoryId: Float
  teacherId: Float
  userId: Float
}

"""
order by stddev() on columns of table "chest_history"
"""
input ChestHistoryStddevOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  userId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type ChestHistoryStddevPopFields {
  chestHistoryId: Float
  chestId: Float
  subcategoryId: Float
  teacherId: Float
  userId: Float
}

"""
order by stddevPop() on columns of table "chest_history"
"""
input ChestHistoryStddevPopOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  userId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type ChestHistoryStddevSampFields {
  chestHistoryId: Float
  chestId: Float
  subcategoryId: Float
  teacherId: Float
  userId: Float
}

"""
order by stddevSamp() on columns of table "chest_history"
"""
input ChestHistoryStddevSampOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  userId: OrderBy
}

"""
Streaming cursor of the table "chest_history"
"""
input ChestHistoryStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: ChestHistoryStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input ChestHistoryStreamCursorValueInput {
  chestHistoryId: bigint
  chestId: bigint
  createdAt: timestamp
  label: String
  opened: Boolean
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  userId: bigint
}

"""
aggregate sum on columns
"""
type ChestHistorySumFields {
  chestHistoryId: bigint
  chestId: bigint
  subcategoryId: bigint
  teacherId: bigint
  userId: bigint
}

"""
order by sum() on columns of table "chest_history"
"""
input ChestHistorySumOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  userId: OrderBy
}

type ChestHistoryType {
  chest: ChestType!
  chestHistoryId: ID!
  createdAt: String!
  label: String!
  opened: Boolean!
  subcategory: SubcategoryType!
  teacher: UserType!
  updatedAt: String!
  user: UserType!
}

"""
update columns of table "chest_history"
"""
enum ChestHistoryUpdateColumn {
  """
  column name
  """
  chestHistoryId

  """
  column name
  """
  chestId

  """
  column name
  """
  createdAt

  """
  column name
  """
  label

  """
  column name
  """
  opened

  """
  column name
  """
  subcategoryId

  """
  column name
  """
  teacherId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  userId
}

input ChestHistoryUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ChestHistoryIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ChestHistorySetInput

  """
  filter the rows which have to be updated
  """
  where: ChestHistoryBoolExp!
}

"""
aggregate varPop on columns
"""
type ChestHistoryVarPopFields {
  chestHistoryId: Float
  chestId: Float
  subcategoryId: Float
  teacherId: Float
  userId: Float
}

"""
order by varPop() on columns of table "chest_history"
"""
input ChestHistoryVarPopOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  userId: OrderBy
}

"""
aggregate varSamp on columns
"""
type ChestHistoryVarSampFields {
  chestHistoryId: Float
  chestId: Float
  subcategoryId: Float
  teacherId: Float
  userId: Float
}

"""
order by varSamp() on columns of table "chest_history"
"""
input ChestHistoryVarSampOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  userId: OrderBy
}

"""
aggregate variance on columns
"""
type ChestHistoryVarianceFields {
  chestHistoryId: Float
  chestId: Float
  subcategoryId: Float
  teacherId: Float
  userId: Float
}

"""
order by variance() on columns of table "chest_history"
"""
input ChestHistoryVarianceOrderBy {
  chestHistoryId: OrderBy
  chestId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  userId: OrderBy
}

type ChestType {
  chestId: ID!
  chestType: String!
  edition: EditionType!
  imageFile: FileType
  label: String!
}

"""
columns and relationships of "chests"
"""
type Chests {
  """
  An array relationship
  """
  chestAwards(
    """
    distinct select on columns
    """
    distinctOn: [ChestAwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestAwardOrderBy!]

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): [ChestAward!]!

  """
  An aggregate relationship
  """
  chestAwardsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestAwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestAwardOrderBy!]

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): ChestAwardAggregate!

  """
  An array relationship
  """
  chestHistories(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): [ChestHistory!]!

  """
  An aggregate relationship
  """
  chestHistoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): ChestHistoryAggregate!
  chestId: bigint!

  """
  An object relationship
  """
  edition: Edition!
  editionId: bigint!

  """
  An object relationship
  """
  file: Files
  imageFileId: bigint
  label: String!
  type: String!
}

"""
aggregated selection of "chests"
"""
type ChestsAggregate {
  aggregate: ChestsAggregateFields
  nodes: [Chests!]!
}

input ChestsAggregateBoolExp {
  count: chestsAggregateBoolExpCount
}

"""
aggregate fields of "chests"
"""
type ChestsAggregateFields {
  avg: ChestsAvgFields
  count(columns: [ChestsSelectColumn!], distinct: Boolean): Int!
  max: ChestsMaxFields
  min: ChestsMinFields
  stddev: ChestsStddevFields
  stddevPop: ChestsStddevPopFields
  stddevSamp: ChestsStddevSampFields
  sum: ChestsSumFields
  varPop: ChestsVarPopFields
  varSamp: ChestsVarSampFields
  variance: ChestsVarianceFields
}

"""
order by aggregate values of table "chests"
"""
input ChestsAggregateOrderBy {
  avg: ChestsAvgOrderBy
  count: OrderBy
  max: ChestsMaxOrderBy
  min: ChestsMinOrderBy
  stddev: ChestsStddevOrderBy
  stddevPop: ChestsStddevPopOrderBy
  stddevSamp: ChestsStddevSampOrderBy
  sum: ChestsSumOrderBy
  varPop: ChestsVarPopOrderBy
  varSamp: ChestsVarSampOrderBy
  variance: ChestsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chests"
"""
input ChestsArrRelInsertInput {
  data: [ChestsInsertInput!]!

  """
  upsert condition
  """
  onConflict: ChestsOnConflict
}

"""
aggregate avg on columns
"""
type ChestsAvgFields {
  chestId: Float
  editionId: Float
  imageFileId: Float
}

"""
order by avg() on columns of table "chests"
"""
input ChestsAvgOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
}

"""
Boolean expression to filter rows from the table "chests". All fields are combined with a logical 'AND'.
"""
input ChestsBoolExp {
  _and: [ChestsBoolExp!]
  _not: ChestsBoolExp
  _or: [ChestsBoolExp!]
  chestAwards: ChestAwardBoolExp
  chestAwardsAggregate: ChestAwardAggregateBoolExp
  chestHistories: ChestHistoryBoolExp
  chestHistoriesAggregate: ChestHistoryAggregateBoolExp
  chestId: BigintComparisonExp
  edition: EditionBoolExp
  editionId: BigintComparisonExp
  file: FilesBoolExp
  imageFileId: BigintComparisonExp
  label: StringComparisonExp
  type: StringComparisonExp
}

"""
unique or primary key constraints on table "chests"
"""
enum ChestsConstraint {
  """
  unique or primary key constraint on columns "chest_id"
  """
  chests_pkey
}

"""
input type for incrementing numeric columns in table "chests"
"""
input ChestsIncInput {
  chestId: bigint
  editionId: bigint
  imageFileId: bigint
}

"""
input type for inserting data into table "chests"
"""
input ChestsInsertInput {
  chestAwards: ChestAwardArrRelInsertInput
  chestHistories: ChestHistoryArrRelInsertInput
  chestId: bigint
  edition: EditionObjRelInsertInput
  editionId: bigint
  file: FilesObjRelInsertInput
  imageFileId: bigint
  label: String
  type: String
}

"""
aggregate max on columns
"""
type ChestsMaxFields {
  chestId: bigint
  editionId: bigint
  imageFileId: bigint
  label: String
  type: String
}

"""
order by max() on columns of table "chests"
"""
input ChestsMaxOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  type: OrderBy
}

"""
aggregate min on columns
"""
type ChestsMinFields {
  chestId: bigint
  editionId: bigint
  imageFileId: bigint
  label: String
  type: String
}

"""
order by min() on columns of table "chests"
"""
input ChestsMinOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  type: OrderBy
}

"""
response of any mutation on the table "chests"
"""
type ChestsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Chests!]!
}

"""
input type for inserting object relation for remote table "chests"
"""
input ChestsObjRelInsertInput {
  data: ChestsInsertInput!

  """
  upsert condition
  """
  onConflict: ChestsOnConflict
}

"""
on_conflict condition type for table "chests"
"""
input ChestsOnConflict {
  constraint: ChestsConstraint!
  updateColumns: [ChestsUpdateColumn!]! = []
  where: ChestsBoolExp
}

"""
Ordering options when selecting data from "chests".
"""
input ChestsOrderBy {
  chestAwardsAggregate: ChestAwardAggregateOrderBy
  chestHistoriesAggregate: ChestHistoryAggregateOrderBy
  chestId: OrderBy
  edition: EditionOrderBy
  editionId: OrderBy
  file: FilesOrderBy
  imageFileId: OrderBy
  label: OrderBy
  type: OrderBy
}

"""
primary key columns input for table: chests
"""
input ChestsPkColumnsInput {
  chestId: bigint!
}

"""
select columns of table "chests"
"""
enum ChestsSelectColumn {
  """
  column name
  """
  chestId

  """
  column name
  """
  editionId

  """
  column name
  """
  imageFileId

  """
  column name
  """
  label

  """
  column name
  """
  type
}

"""
input type for updating data in table "chests"
"""
input ChestsSetInput {
  chestId: bigint
  editionId: bigint
  imageFileId: bigint
  label: String
  type: String
}

"""
aggregate stddev on columns
"""
type ChestsStddevFields {
  chestId: Float
  editionId: Float
  imageFileId: Float
}

"""
order by stddev() on columns of table "chests"
"""
input ChestsStddevOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type ChestsStddevPopFields {
  chestId: Float
  editionId: Float
  imageFileId: Float
}

"""
order by stddevPop() on columns of table "chests"
"""
input ChestsStddevPopOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type ChestsStddevSampFields {
  chestId: Float
  editionId: Float
  imageFileId: Float
}

"""
order by stddevSamp() on columns of table "chests"
"""
input ChestsStddevSampOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
}

"""
Streaming cursor of the table "chests"
"""
input ChestsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: ChestsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input ChestsStreamCursorValueInput {
  chestId: bigint
  editionId: bigint
  imageFileId: bigint
  label: String
  type: String
}

"""
aggregate sum on columns
"""
type ChestsSumFields {
  chestId: bigint
  editionId: bigint
  imageFileId: bigint
}

"""
order by sum() on columns of table "chests"
"""
input ChestsSumOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
}

"""
update columns of table "chests"
"""
enum ChestsUpdateColumn {
  """
  column name
  """
  chestId

  """
  column name
  """
  editionId

  """
  column name
  """
  imageFileId

  """
  column name
  """
  label

  """
  column name
  """
  type
}

input ChestsUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ChestsIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ChestsSetInput

  """
  filter the rows which have to be updated
  """
  where: ChestsBoolExp!
}

"""
aggregate varPop on columns
"""
type ChestsVarPopFields {
  chestId: Float
  editionId: Float
  imageFileId: Float
}

"""
order by varPop() on columns of table "chests"
"""
input ChestsVarPopOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
}

"""
aggregate varSamp on columns
"""
type ChestsVarSampFields {
  chestId: Float
  editionId: Float
  imageFileId: Float
}

"""
order by varSamp() on columns of table "chests"
"""
input ChestsVarSampOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
}

"""
aggregate variance on columns
"""
type ChestsVarianceFields {
  chestId: Float
  editionId: Float
  imageFileId: Float
}

"""
order by variance() on columns of table "chests"
"""
input ChestsVarianceOrderBy {
  chestId: OrderBy
  editionId: OrderBy
  imageFileId: OrderBy
}

"""
ordering argument of a cursor
"""
enum CursorOrdering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input DateComparisonExp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _isNull: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "edition"
"""
type Edition {
  """
  An array relationship
  """
  awardEditions(
    """
    distinct select on columns
    """
    distinctOn: [AwardEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardEditionOrderBy!]

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): [AwardEdition!]!

  """
  An aggregate relationship
  """
  awardEditionsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AwardEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardEditionOrderBy!]

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): AwardEditionAggregate!

  """
  An array relationship
  """
  categoryEditions(
    """
    distinct select on columns
    """
    distinctOn: [CategoryEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoryEditionOrderBy!]

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): [CategoryEdition!]!

  """
  An aggregate relationship
  """
  categoryEditionsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [CategoryEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoryEditionOrderBy!]

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): CategoryEditionAggregate!

  """
  An array relationship
  """
  chests(
    """
    distinct select on columns
    """
    distinctOn: [ChestsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestsOrderBy!]

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): [Chests!]!

  """
  An aggregate relationship
  """
  chestsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestsOrderBy!]

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): ChestsAggregate!
  editionId: bigint!
  editionYear: Int!
  endDate: date!

  """
  An array relationship
  """
  groups(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): [Groups!]!

  """
  An aggregate relationship
  """
  groupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): GroupsAggregate!
  label: String!

  """
  An array relationship
  """
  levels(
    """
    distinct select on columns
    """
    distinctOn: [LevelsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LevelsOrderBy!]

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): [Levels!]!

  """
  An aggregate relationship
  """
  levelsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LevelsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LevelsOrderBy!]

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): LevelsAggregate!
  name: String!
  startDate: date!

  """
  An array relationship
  """
  subcategories(
    """
    distinct select on columns
    """
    distinctOn: [SubcategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SubcategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): [Subcategories!]!

  """
  An aggregate relationship
  """
  subcategoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SubcategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SubcategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): SubcategoriesAggregate!

  """
  An array relationship
  """
  userLevels(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): [UserLevel!]!

  """
  An aggregate relationship
  """
  userLevelsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): UserLevelAggregate!
}

"""
aggregated selection of "edition"
"""
type EditionAggregate {
  aggregate: EditionAggregateFields
  nodes: [Edition!]!
}

"""
aggregate fields of "edition"
"""
type EditionAggregateFields {
  avg: EditionAvgFields
  count(columns: [EditionSelectColumn!], distinct: Boolean): Int!
  max: EditionMaxFields
  min: EditionMinFields
  stddev: EditionStddevFields
  stddevPop: EditionStddevPopFields
  stddevSamp: EditionStddevSampFields
  sum: EditionSumFields
  varPop: EditionVarPopFields
  varSamp: EditionVarSampFields
  variance: EditionVarianceFields
}

"""
aggregate avg on columns
"""
type EditionAvgFields {
  editionId: Float
  editionYear: Float
}

"""
Boolean expression to filter rows from the table "edition". All fields are combined with a logical 'AND'.
"""
input EditionBoolExp {
  _and: [EditionBoolExp!]
  _not: EditionBoolExp
  _or: [EditionBoolExp!]
  awardEditions: AwardEditionBoolExp
  awardEditionsAggregate: AwardEditionAggregateBoolExp
  categoryEditions: CategoryEditionBoolExp
  categoryEditionsAggregate: CategoryEditionAggregateBoolExp
  chests: ChestsBoolExp
  chestsAggregate: ChestsAggregateBoolExp
  editionId: BigintComparisonExp
  editionYear: IntComparisonExp
  endDate: DateComparisonExp
  groups: GroupsBoolExp
  groupsAggregate: GroupsAggregateBoolExp
  label: StringComparisonExp
  levels: LevelsBoolExp
  levelsAggregate: LevelsAggregateBoolExp
  name: StringComparisonExp
  startDate: DateComparisonExp
  subcategories: SubcategoriesBoolExp
  subcategoriesAggregate: SubcategoriesAggregateBoolExp
  userLevels: UserLevelBoolExp
  userLevelsAggregate: UserLevelAggregateBoolExp
}

"""
unique or primary key constraints on table "edition"
"""
enum EditionConstraint {
  """
  unique or primary key constraint on columns "edition_id"
  """
  edition_pkey
}

"""
input type for incrementing numeric columns in table "edition"
"""
input EditionIncInput {
  editionId: bigint
  editionYear: Int
}

"""
input type for inserting data into table "edition"
"""
input EditionInsertInput {
  awardEditions: AwardEditionArrRelInsertInput
  categoryEditions: CategoryEditionArrRelInsertInput
  chests: ChestsArrRelInsertInput
  editionId: bigint
  editionYear: Int
  endDate: date
  groups: GroupsArrRelInsertInput
  label: String
  levels: LevelsArrRelInsertInput
  name: String
  startDate: date
  subcategories: SubcategoriesArrRelInsertInput
  userLevels: UserLevelArrRelInsertInput
}

"""
aggregate max on columns
"""
type EditionMaxFields {
  editionId: bigint
  editionYear: Int
  endDate: date
  label: String
  name: String
  startDate: date
}

"""
aggregate min on columns
"""
type EditionMinFields {
  editionId: bigint
  editionYear: Int
  endDate: date
  label: String
  name: String
  startDate: date
}

"""
response of any mutation on the table "edition"
"""
type EditionMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Edition!]!
}

"""
input type for inserting object relation for remote table "edition"
"""
input EditionObjRelInsertInput {
  data: EditionInsertInput!

  """
  upsert condition
  """
  onConflict: EditionOnConflict
}

"""
on_conflict condition type for table "edition"
"""
input EditionOnConflict {
  constraint: EditionConstraint!
  updateColumns: [EditionUpdateColumn!]! = []
  where: EditionBoolExp
}

"""
Ordering options when selecting data from "edition".
"""
input EditionOrderBy {
  awardEditionsAggregate: AwardEditionAggregateOrderBy
  categoryEditionsAggregate: CategoryEditionAggregateOrderBy
  chestsAggregate: ChestsAggregateOrderBy
  editionId: OrderBy
  editionYear: OrderBy
  endDate: OrderBy
  groupsAggregate: GroupsAggregateOrderBy
  label: OrderBy
  levelsAggregate: LevelsAggregateOrderBy
  name: OrderBy
  startDate: OrderBy
  subcategoriesAggregate: SubcategoriesAggregateOrderBy
  userLevelsAggregate: UserLevelAggregateOrderBy
}

"""
primary key columns input for table: edition
"""
input EditionPkColumnsInput {
  editionId: bigint!
}

"""
select columns of table "edition"
"""
enum EditionSelectColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  editionYear

  """
  column name
  """
  endDate

  """
  column name
  """
  label

  """
  column name
  """
  name

  """
  column name
  """
  startDate
}

"""
input type for updating data in table "edition"
"""
input EditionSetInput {
  editionId: bigint
  editionYear: Int
  endDate: date
  label: String
  name: String
  startDate: date
}

"""
aggregate stddev on columns
"""
type EditionStddevFields {
  editionId: Float
  editionYear: Float
}

"""
aggregate stddevPop on columns
"""
type EditionStddevPopFields {
  editionId: Float
  editionYear: Float
}

"""
aggregate stddevSamp on columns
"""
type EditionStddevSampFields {
  editionId: Float
  editionYear: Float
}

"""
Streaming cursor of the table "edition"
"""
input EditionStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: EditionStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input EditionStreamCursorValueInput {
  editionId: bigint
  editionYear: Int
  endDate: date
  label: String
  name: String
  startDate: date
}

"""
aggregate sum on columns
"""
type EditionSumFields {
  editionId: bigint
  editionYear: Int
}

type EditionType {
  editionId: ID!
  editionName: String!
  editionYear: Int!
  endDate: String!
  label: String!
  startDate: String!
}

"""
update columns of table "edition"
"""
enum EditionUpdateColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  editionYear

  """
  column name
  """
  endDate

  """
  column name
  """
  label

  """
  column name
  """
  name

  """
  column name
  """
  startDate
}

input EditionUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: EditionIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: EditionSetInput

  """
  filter the rows which have to be updated
  """
  where: EditionBoolExp!
}

"""
aggregate varPop on columns
"""
type EditionVarPopFields {
  editionId: Float
  editionYear: Float
}

"""
aggregate varSamp on columns
"""
type EditionVarSampFields {
  editionId: Float
  editionYear: Float
}

"""
aggregate variance on columns
"""
type EditionVarianceFields {
  editionId: Float
  editionYear: Float
}

type FileType {
  fileId: ID!
  fileName: String!
  fileType: String!
  label: String!
  pathToFile: String!
}

"""
columns and relationships of "files"
"""
type Files {
  """
  An array relationship
  """
  awards(
    """
    distinct select on columns
    """
    distinctOn: [AwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardOrderBy!]

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): [Award!]!

  """
  An aggregate relationship
  """
  awardsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardOrderBy!]

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): AwardAggregate!

  """
  An array relationship
  """
  chests(
    """
    distinct select on columns
    """
    distinctOn: [ChestsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestsOrderBy!]

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): [Chests!]!

  """
  An aggregate relationship
  """
  chestsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestsOrderBy!]

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): ChestsAggregate!
  fileId: bigint!
  fileName: String!
  fileType: String!

  """
  An array relationship
  """
  groups(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): [Groups!]!

  """
  An aggregate relationship
  """
  groupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): GroupsAggregate!
  label: String!

  """
  An array relationship
  """
  levels(
    """
    distinct select on columns
    """
    distinctOn: [LevelsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LevelsOrderBy!]

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): [Levels!]!

  """
  An aggregate relationship
  """
  levelsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LevelsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LevelsOrderBy!]

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): LevelsAggregate!
  pathToFile: String!

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): [Users!]!

  """
  An aggregate relationship
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): UsersAggregate!
}

"""
aggregated selection of "files"
"""
type FilesAggregate {
  aggregate: FilesAggregateFields
  nodes: [Files!]!
}

"""
aggregate fields of "files"
"""
type FilesAggregateFields {
  avg: FilesAvgFields
  count(columns: [FilesSelectColumn!], distinct: Boolean): Int!
  max: FilesMaxFields
  min: FilesMinFields
  stddev: FilesStddevFields
  stddevPop: FilesStddevPopFields
  stddevSamp: FilesStddevSampFields
  sum: FilesSumFields
  varPop: FilesVarPopFields
  varSamp: FilesVarSampFields
  variance: FilesVarianceFields
}

"""
aggregate avg on columns
"""
type FilesAvgFields {
  fileId: Float
}

"""
Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'.
"""
input FilesBoolExp {
  _and: [FilesBoolExp!]
  _not: FilesBoolExp
  _or: [FilesBoolExp!]
  awards: AwardBoolExp
  awardsAggregate: AwardAggregateBoolExp
  chests: ChestsBoolExp
  chestsAggregate: ChestsAggregateBoolExp
  fileId: BigintComparisonExp
  fileName: StringComparisonExp
  fileType: StringComparisonExp
  groups: GroupsBoolExp
  groupsAggregate: GroupsAggregateBoolExp
  label: StringComparisonExp
  levels: LevelsBoolExp
  levelsAggregate: LevelsAggregateBoolExp
  pathToFile: StringComparisonExp
  users: UsersBoolExp
  usersAggregate: UsersAggregateBoolExp
}

"""
unique or primary key constraints on table "files"
"""
enum FilesConstraint {
  """
  unique or primary key constraint on columns "file_id"
  """
  files_pkey
}

"""
input type for incrementing numeric columns in table "files"
"""
input FilesIncInput {
  fileId: bigint
}

"""
input type for inserting data into table "files"
"""
input FilesInsertInput {
  awards: AwardArrRelInsertInput
  chests: ChestsArrRelInsertInput
  fileId: bigint
  fileName: String
  fileType: String
  groups: GroupsArrRelInsertInput
  label: String
  levels: LevelsArrRelInsertInput
  pathToFile: String
  users: UsersArrRelInsertInput
}

"""
aggregate max on columns
"""
type FilesMaxFields {
  fileId: bigint
  fileName: String
  fileType: String
  label: String
  pathToFile: String
}

"""
aggregate min on columns
"""
type FilesMinFields {
  fileId: bigint
  fileName: String
  fileType: String
  label: String
  pathToFile: String
}

"""
response of any mutation on the table "files"
"""
type FilesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Files!]!
}

"""
input type for inserting object relation for remote table "files"
"""
input FilesObjRelInsertInput {
  data: FilesInsertInput!

  """
  upsert condition
  """
  onConflict: FilesOnConflict
}

"""
on_conflict condition type for table "files"
"""
input FilesOnConflict {
  constraint: FilesConstraint!
  updateColumns: [FilesUpdateColumn!]! = []
  where: FilesBoolExp
}

"""
Ordering options when selecting data from "files".
"""
input FilesOrderBy {
  awardsAggregate: AwardAggregateOrderBy
  chestsAggregate: ChestsAggregateOrderBy
  fileId: OrderBy
  fileName: OrderBy
  fileType: OrderBy
  groupsAggregate: GroupsAggregateOrderBy
  label: OrderBy
  levelsAggregate: LevelsAggregateOrderBy
  pathToFile: OrderBy
  usersAggregate: UsersAggregateOrderBy
}

"""
primary key columns input for table: files
"""
input FilesPkColumnsInput {
  fileId: bigint!
}

"""
select columns of table "files"
"""
enum FilesSelectColumn {
  """
  column name
  """
  fileId

  """
  column name
  """
  fileName

  """
  column name
  """
  fileType

  """
  column name
  """
  label

  """
  column name
  """
  pathToFile
}

"""
input type for updating data in table "files"
"""
input FilesSetInput {
  fileId: bigint
  fileName: String
  fileType: String
  label: String
  pathToFile: String
}

"""
aggregate stddev on columns
"""
type FilesStddevFields {
  fileId: Float
}

"""
aggregate stddevPop on columns
"""
type FilesStddevPopFields {
  fileId: Float
}

"""
aggregate stddevSamp on columns
"""
type FilesStddevSampFields {
  fileId: Float
}

"""
Streaming cursor of the table "files"
"""
input FilesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: FilesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input FilesStreamCursorValueInput {
  fileId: bigint
  fileName: String
  fileType: String
  label: String
  pathToFile: String
}

"""
aggregate sum on columns
"""
type FilesSumFields {
  fileId: bigint
}

"""
update columns of table "files"
"""
enum FilesUpdateColumn {
  """
  column name
  """
  fileId

  """
  column name
  """
  fileName

  """
  column name
  """
  fileType

  """
  column name
  """
  label

  """
  column name
  """
  pathToFile
}

input FilesUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: FilesIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: FilesSetInput

  """
  filter the rows which have to be updated
  """
  where: FilesBoolExp!
}

"""
aggregate varPop on columns
"""
type FilesVarPopFields {
  fileId: Float
}

"""
aggregate varSamp on columns
"""
type FilesVarSampFields {
  fileId: Float
}

"""
aggregate variance on columns
"""
type FilesVarianceFields {
  fileId: Float
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input FloatComparisonExp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _isNull: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
columns and relationships of "flyway_schema_history"
"""
type FlywaySchemaHistory {
  checksum: Int
  description: String!
  executionTime: Int!
  installedBy: String!
  installedOn: timestamp!
  installedRank: Int!
  script: String!
  success: Boolean!
  type: String!
  version: String
}

"""
aggregated selection of "flyway_schema_history"
"""
type FlywaySchemaHistoryAggregate {
  aggregate: FlywaySchemaHistoryAggregateFields
  nodes: [FlywaySchemaHistory!]!
}

"""
aggregate fields of "flyway_schema_history"
"""
type FlywaySchemaHistoryAggregateFields {
  avg: FlywaySchemaHistoryAvgFields
  count(columns: [FlywaySchemaHistorySelectColumn!], distinct: Boolean): Int!
  max: FlywaySchemaHistoryMaxFields
  min: FlywaySchemaHistoryMinFields
  stddev: FlywaySchemaHistoryStddevFields
  stddevPop: FlywaySchemaHistoryStddevPopFields
  stddevSamp: FlywaySchemaHistoryStddevSampFields
  sum: FlywaySchemaHistorySumFields
  varPop: FlywaySchemaHistoryVarPopFields
  varSamp: FlywaySchemaHistoryVarSampFields
  variance: FlywaySchemaHistoryVarianceFields
}

"""
aggregate avg on columns
"""
type FlywaySchemaHistoryAvgFields {
  checksum: Float
  executionTime: Float
  installedRank: Float
}

"""
Boolean expression to filter rows from the table "flyway_schema_history". All fields are combined with a logical 'AND'.
"""
input FlywaySchemaHistoryBoolExp {
  _and: [FlywaySchemaHistoryBoolExp!]
  _not: FlywaySchemaHistoryBoolExp
  _or: [FlywaySchemaHistoryBoolExp!]
  checksum: IntComparisonExp
  description: StringComparisonExp
  executionTime: IntComparisonExp
  installedBy: StringComparisonExp
  installedOn: TimestampComparisonExp
  installedRank: IntComparisonExp
  script: StringComparisonExp
  success: BooleanComparisonExp
  type: StringComparisonExp
  version: StringComparisonExp
}

"""
unique or primary key constraints on table "flyway_schema_history"
"""
enum FlywaySchemaHistoryConstraint {
  """
  unique or primary key constraint on columns "installed_rank"
  """
  flyway_schema_history_pk
}

"""
input type for incrementing numeric columns in table "flyway_schema_history"
"""
input FlywaySchemaHistoryIncInput {
  checksum: Int
  executionTime: Int
  installedRank: Int
}

"""
input type for inserting data into table "flyway_schema_history"
"""
input FlywaySchemaHistoryInsertInput {
  checksum: Int
  description: String
  executionTime: Int
  installedBy: String
  installedOn: timestamp
  installedRank: Int
  script: String
  success: Boolean
  type: String
  version: String
}

"""
aggregate max on columns
"""
type FlywaySchemaHistoryMaxFields {
  checksum: Int
  description: String
  executionTime: Int
  installedBy: String
  installedOn: timestamp
  installedRank: Int
  script: String
  type: String
  version: String
}

"""
aggregate min on columns
"""
type FlywaySchemaHistoryMinFields {
  checksum: Int
  description: String
  executionTime: Int
  installedBy: String
  installedOn: timestamp
  installedRank: Int
  script: String
  type: String
  version: String
}

"""
response of any mutation on the table "flyway_schema_history"
"""
type FlywaySchemaHistoryMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [FlywaySchemaHistory!]!
}

"""
on_conflict condition type for table "flyway_schema_history"
"""
input FlywaySchemaHistoryOnConflict {
  constraint: FlywaySchemaHistoryConstraint!
  updateColumns: [FlywaySchemaHistoryUpdateColumn!]! = []
  where: FlywaySchemaHistoryBoolExp
}

"""
Ordering options when selecting data from "flyway_schema_history".
"""
input FlywaySchemaHistoryOrderBy {
  checksum: OrderBy
  description: OrderBy
  executionTime: OrderBy
  installedBy: OrderBy
  installedOn: OrderBy
  installedRank: OrderBy
  script: OrderBy
  success: OrderBy
  type: OrderBy
  version: OrderBy
}

"""
primary key columns input for table: flyway_schema_history
"""
input FlywaySchemaHistoryPkColumnsInput {
  installedRank: Int!
}

"""
select columns of table "flyway_schema_history"
"""
enum FlywaySchemaHistorySelectColumn {
  """
  column name
  """
  checksum

  """
  column name
  """
  description

  """
  column name
  """
  executionTime

  """
  column name
  """
  installedBy

  """
  column name
  """
  installedOn

  """
  column name
  """
  installedRank

  """
  column name
  """
  script

  """
  column name
  """
  success

  """
  column name
  """
  type

  """
  column name
  """
  version
}

"""
input type for updating data in table "flyway_schema_history"
"""
input FlywaySchemaHistorySetInput {
  checksum: Int
  description: String
  executionTime: Int
  installedBy: String
  installedOn: timestamp
  installedRank: Int
  script: String
  success: Boolean
  type: String
  version: String
}

"""
aggregate stddev on columns
"""
type FlywaySchemaHistoryStddevFields {
  checksum: Float
  executionTime: Float
  installedRank: Float
}

"""
aggregate stddevPop on columns
"""
type FlywaySchemaHistoryStddevPopFields {
  checksum: Float
  executionTime: Float
  installedRank: Float
}

"""
aggregate stddevSamp on columns
"""
type FlywaySchemaHistoryStddevSampFields {
  checksum: Float
  executionTime: Float
  installedRank: Float
}

"""
Streaming cursor of the table "flyway_schema_history"
"""
input FlywaySchemaHistoryStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: FlywaySchemaHistoryStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input FlywaySchemaHistoryStreamCursorValueInput {
  checksum: Int
  description: String
  executionTime: Int
  installedBy: String
  installedOn: timestamp
  installedRank: Int
  script: String
  success: Boolean
  type: String
  version: String
}

"""
aggregate sum on columns
"""
type FlywaySchemaHistorySumFields {
  checksum: Int
  executionTime: Int
  installedRank: Int
}

"""
update columns of table "flyway_schema_history"
"""
enum FlywaySchemaHistoryUpdateColumn {
  """
  column name
  """
  checksum

  """
  column name
  """
  description

  """
  column name
  """
  executionTime

  """
  column name
  """
  installedBy

  """
  column name
  """
  installedOn

  """
  column name
  """
  installedRank

  """
  column name
  """
  script

  """
  column name
  """
  success

  """
  column name
  """
  type

  """
  column name
  """
  version
}

input FlywaySchemaHistoryUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: FlywaySchemaHistoryIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: FlywaySchemaHistorySetInput

  """
  filter the rows which have to be updated
  """
  where: FlywaySchemaHistoryBoolExp!
}

"""
aggregate varPop on columns
"""
type FlywaySchemaHistoryVarPopFields {
  checksum: Float
  executionTime: Float
  installedRank: Float
}

"""
aggregate varSamp on columns
"""
type FlywaySchemaHistoryVarSampFields {
  checksum: Float
  executionTime: Float
  installedRank: Float
}

"""
aggregate variance on columns
"""
type FlywaySchemaHistoryVarianceFields {
  checksum: Float
  executionTime: Float
  installedRank: Float
}

type GroupDateType {
  endTime: String!
  startTime: String!
  weekday: WeekdayType!
}

type GroupTeacherType {
  canEdit: Boolean!
  group: GroupType!
  owns: Boolean!
}

type GroupType {
  edition: EditionType!
  endTime: String!
  groupName: String!
  groupsId: ID!
  imageFile: FileType
  label: String
  startTime: String!
  teacher: UserType!
  userGroups: [UserGroupType]!
  weekday: WeekdayType!
}

"""
columns and relationships of "groups"
"""
type Groups {
  """
  An object relationship
  """
  edition: Edition!
  editionId: bigint!
  endTime: time!

  """
  An object relationship
  """
  file: Files
  groupName: String!
  groupsId: bigint!
  imageFileId: bigint
  label: String
  startTime: time!
  teacherId: bigint!

  """
  An object relationship
  """
  user: Users!

  """
  An object relationship
  """
  userByTeacherId: Users

  """
  An array relationship
  """
  userGroups(
    """
    distinct select on columns
    """
    distinctOn: [UserGroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserGroupsOrderBy!]

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): [UserGroups!]!

  """
  An aggregate relationship
  """
  userGroupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserGroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserGroupsOrderBy!]

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): UserGroupsAggregate!

  """
  An object relationship
  """
  weekday: Weekdays!
  weekdayId: bigint!
}

"""
aggregated selection of "groups"
"""
type GroupsAggregate {
  aggregate: GroupsAggregateFields
  nodes: [Groups!]!
}

input GroupsAggregateBoolExp {
  count: groupsAggregateBoolExpCount
}

"""
aggregate fields of "groups"
"""
type GroupsAggregateFields {
  avg: GroupsAvgFields
  count(columns: [GroupsSelectColumn!], distinct: Boolean): Int!
  max: GroupsMaxFields
  min: GroupsMinFields
  stddev: GroupsStddevFields
  stddevPop: GroupsStddevPopFields
  stddevSamp: GroupsStddevSampFields
  sum: GroupsSumFields
  varPop: GroupsVarPopFields
  varSamp: GroupsVarSampFields
  variance: GroupsVarianceFields
}

"""
order by aggregate values of table "groups"
"""
input GroupsAggregateOrderBy {
  avg: GroupsAvgOrderBy
  count: OrderBy
  max: GroupsMaxOrderBy
  min: GroupsMinOrderBy
  stddev: GroupsStddevOrderBy
  stddevPop: GroupsStddevPopOrderBy
  stddevSamp: GroupsStddevSampOrderBy
  sum: GroupsSumOrderBy
  varPop: GroupsVarPopOrderBy
  varSamp: GroupsVarSampOrderBy
  variance: GroupsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "groups"
"""
input GroupsArrRelInsertInput {
  data: [GroupsInsertInput!]!

  """
  upsert condition
  """
  onConflict: GroupsOnConflict
}

"""
aggregate avg on columns
"""
type GroupsAvgFields {
  editionId: Float
  groupsId: Float
  imageFileId: Float
  teacherId: Float
  weekdayId: Float
}

"""
order by avg() on columns of table "groups"
"""
input GroupsAvgOrderBy {
  editionId: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
Boolean expression to filter rows from the table "groups". All fields are combined with a logical 'AND'.
"""
input GroupsBoolExp {
  _and: [GroupsBoolExp!]
  _not: GroupsBoolExp
  _or: [GroupsBoolExp!]
  edition: EditionBoolExp
  editionId: BigintComparisonExp
  endTime: TimeComparisonExp
  file: FilesBoolExp
  groupName: StringComparisonExp
  groupsId: BigintComparisonExp
  imageFileId: BigintComparisonExp
  label: StringComparisonExp
  startTime: TimeComparisonExp
  teacherId: BigintComparisonExp
  user: UsersBoolExp
  userByTeacherId: UsersBoolExp
  userGroups: UserGroupsBoolExp
  userGroupsAggregate: UserGroupsAggregateBoolExp
  weekday: WeekdaysBoolExp
  weekdayId: BigintComparisonExp
}

"""
unique or primary key constraints on table "groups"
"""
enum GroupsConstraint {
  """
  unique or primary key constraint on columns "groups_id"
  """
  groups_pkey
}

"""
input type for incrementing numeric columns in table "groups"
"""
input GroupsIncInput {
  editionId: bigint
  groupsId: bigint
  imageFileId: bigint
  teacherId: bigint
  weekdayId: bigint
}

"""
input type for inserting data into table "groups"
"""
input GroupsInsertInput {
  edition: EditionObjRelInsertInput
  editionId: bigint
  endTime: time
  file: FilesObjRelInsertInput
  groupName: String
  groupsId: bigint
  imageFileId: bigint
  label: String
  startTime: time
  teacherId: bigint
  user: UsersObjRelInsertInput
  userByTeacherId: UsersObjRelInsertInput
  userGroups: UserGroupsArrRelInsertInput
  weekday: WeekdaysObjRelInsertInput
  weekdayId: bigint
}

"""
aggregate max on columns
"""
type GroupsMaxFields {
  editionId: bigint
  groupName: String
  groupsId: bigint
  imageFileId: bigint
  label: String
  teacherId: bigint
  weekdayId: bigint
}

"""
order by max() on columns of table "groups"
"""
input GroupsMaxOrderBy {
  editionId: OrderBy
  groupName: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
aggregate min on columns
"""
type GroupsMinFields {
  editionId: bigint
  groupName: String
  groupsId: bigint
  imageFileId: bigint
  label: String
  teacherId: bigint
  weekdayId: bigint
}

"""
order by min() on columns of table "groups"
"""
input GroupsMinOrderBy {
  editionId: OrderBy
  groupName: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
response of any mutation on the table "groups"
"""
type GroupsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Groups!]!
}

"""
input type for inserting object relation for remote table "groups"
"""
input GroupsObjRelInsertInput {
  data: GroupsInsertInput!

  """
  upsert condition
  """
  onConflict: GroupsOnConflict
}

"""
on_conflict condition type for table "groups"
"""
input GroupsOnConflict {
  constraint: GroupsConstraint!
  updateColumns: [GroupsUpdateColumn!]! = []
  where: GroupsBoolExp
}

"""
Ordering options when selecting data from "groups".
"""
input GroupsOrderBy {
  edition: EditionOrderBy
  editionId: OrderBy
  endTime: OrderBy
  file: FilesOrderBy
  groupName: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  startTime: OrderBy
  teacherId: OrderBy
  user: UsersOrderBy
  userByTeacherId: UsersOrderBy
  userGroupsAggregate: UserGroupsAggregateOrderBy
  weekday: WeekdaysOrderBy
  weekdayId: OrderBy
}

"""
primary key columns input for table: groups
"""
input GroupsPkColumnsInput {
  groupsId: bigint!
}

"""
select columns of table "groups"
"""
enum GroupsSelectColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  endTime

  """
  column name
  """
  groupName

  """
  column name
  """
  groupsId

  """
  column name
  """
  imageFileId

  """
  column name
  """
  label

  """
  column name
  """
  startTime

  """
  column name
  """
  teacherId

  """
  column name
  """
  weekdayId
}

"""
input type for updating data in table "groups"
"""
input GroupsSetInput {
  editionId: bigint
  endTime: time
  groupName: String
  groupsId: bigint
  imageFileId: bigint
  label: String
  startTime: time
  teacherId: bigint
  weekdayId: bigint
}

"""
aggregate stddev on columns
"""
type GroupsStddevFields {
  editionId: Float
  groupsId: Float
  imageFileId: Float
  teacherId: Float
  weekdayId: Float
}

"""
order by stddev() on columns of table "groups"
"""
input GroupsStddevOrderBy {
  editionId: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type GroupsStddevPopFields {
  editionId: Float
  groupsId: Float
  imageFileId: Float
  teacherId: Float
  weekdayId: Float
}

"""
order by stddevPop() on columns of table "groups"
"""
input GroupsStddevPopOrderBy {
  editionId: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type GroupsStddevSampFields {
  editionId: Float
  groupsId: Float
  imageFileId: Float
  teacherId: Float
  weekdayId: Float
}

"""
order by stddevSamp() on columns of table "groups"
"""
input GroupsStddevSampOrderBy {
  editionId: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
Streaming cursor of the table "groups"
"""
input GroupsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: GroupsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input GroupsStreamCursorValueInput {
  editionId: bigint
  endTime: time
  groupName: String
  groupsId: bigint
  imageFileId: bigint
  label: String
  startTime: time
  teacherId: bigint
  weekdayId: bigint
}

"""
aggregate sum on columns
"""
type GroupsSumFields {
  editionId: bigint
  groupsId: bigint
  imageFileId: bigint
  teacherId: bigint
  weekdayId: bigint
}

"""
order by sum() on columns of table "groups"
"""
input GroupsSumOrderBy {
  editionId: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
update columns of table "groups"
"""
enum GroupsUpdateColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  endTime

  """
  column name
  """
  groupName

  """
  column name
  """
  groupsId

  """
  column name
  """
  imageFileId

  """
  column name
  """
  label

  """
  column name
  """
  startTime

  """
  column name
  """
  teacherId

  """
  column name
  """
  weekdayId
}

input GroupsUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: GroupsIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: GroupsSetInput

  """
  filter the rows which have to be updated
  """
  where: GroupsBoolExp!
}

"""
aggregate varPop on columns
"""
type GroupsVarPopFields {
  editionId: Float
  groupsId: Float
  imageFileId: Float
  teacherId: Float
  weekdayId: Float
}

"""
order by varPop() on columns of table "groups"
"""
input GroupsVarPopOrderBy {
  editionId: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
aggregate varSamp on columns
"""
type GroupsVarSampFields {
  editionId: Float
  groupsId: Float
  imageFileId: Float
  teacherId: Float
  weekdayId: Float
}

"""
order by varSamp() on columns of table "groups"
"""
input GroupsVarSampOrderBy {
  editionId: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
aggregate variance on columns
"""
type GroupsVarianceFields {
  editionId: Float
  groupsId: Float
  imageFileId: Float
  teacherId: Float
  weekdayId: Float
}

"""
order by variance() on columns of table "groups"
"""
input GroupsVarianceOrderBy {
  editionId: OrderBy
  groupsId: OrderBy
  imageFileId: OrderBy
  teacherId: OrderBy
  weekdayId: OrderBy
}

"""
columns and relationships of "hall_of_fame"
"""
type HallOfFame {
  editionId: bigint
  groupName: String
  groupsId: bigint
  levelId: bigint
  levelImageId: bigint
  levelName: String
  nick: String
  sumOfPoints: numeric
  userId: bigint
  userImageId: bigint
}

"""
aggregated selection of "hall_of_fame"
"""
type HallOfFameAggregate {
  aggregate: HallOfFameAggregateFields
  nodes: [HallOfFame!]!
}

"""
aggregate fields of "hall_of_fame"
"""
type HallOfFameAggregateFields {
  avg: HallOfFameAvgFields
  count(columns: [HallOfFameSelectColumn!], distinct: Boolean): Int!
  max: HallOfFameMaxFields
  min: HallOfFameMinFields
  stddev: HallOfFameStddevFields
  stddevPop: HallOfFameStddevPopFields
  stddevSamp: HallOfFameStddevSampFields
  sum: HallOfFameSumFields
  varPop: HallOfFameVarPopFields
  varSamp: HallOfFameVarSampFields
  variance: HallOfFameVarianceFields
}

"""
aggregate avg on columns
"""
type HallOfFameAvgFields {
  editionId: Float
  groupsId: Float
  levelId: Float
  levelImageId: Float
  sumOfPoints: Float
  userId: Float
  userImageId: Float
}

"""
Boolean expression to filter rows from the table "hall_of_fame". All fields are combined with a logical 'AND'.
"""
input HallOfFameBoolExp {
  _and: [HallOfFameBoolExp!]
  _not: HallOfFameBoolExp
  _or: [HallOfFameBoolExp!]
  editionId: BigintComparisonExp
  groupName: StringComparisonExp
  groupsId: BigintComparisonExp
  levelId: BigintComparisonExp
  levelImageId: BigintComparisonExp
  levelName: StringComparisonExp
  nick: StringComparisonExp
  sumOfPoints: NumericComparisonExp
  userId: BigintComparisonExp
  userImageId: BigintComparisonExp
}

"""
aggregate max on columns
"""
type HallOfFameMaxFields {
  editionId: bigint
  groupName: String
  groupsId: bigint
  levelId: bigint
  levelImageId: bigint
  levelName: String
  nick: String
  sumOfPoints: numeric
  userId: bigint
  userImageId: bigint
}

"""
aggregate min on columns
"""
type HallOfFameMinFields {
  editionId: bigint
  groupName: String
  groupsId: bigint
  levelId: bigint
  levelImageId: bigint
  levelName: String
  nick: String
  sumOfPoints: numeric
  userId: bigint
  userImageId: bigint
}

"""
Ordering options when selecting data from "hall_of_fame".
"""
input HallOfFameOrderBy {
  editionId: OrderBy
  groupName: OrderBy
  groupsId: OrderBy
  levelId: OrderBy
  levelImageId: OrderBy
  levelName: OrderBy
  nick: OrderBy
  sumOfPoints: OrderBy
  userId: OrderBy
  userImageId: OrderBy
}

"""
select columns of table "hall_of_fame"
"""
enum HallOfFameSelectColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  groupName

  """
  column name
  """
  groupsId

  """
  column name
  """
  levelId

  """
  column name
  """
  levelImageId

  """
  column name
  """
  levelName

  """
  column name
  """
  nick

  """
  column name
  """
  sumOfPoints

  """
  column name
  """
  userId

  """
  column name
  """
  userImageId
}

"""
aggregate stddev on columns
"""
type HallOfFameStddevFields {
  editionId: Float
  groupsId: Float
  levelId: Float
  levelImageId: Float
  sumOfPoints: Float
  userId: Float
  userImageId: Float
}

"""
aggregate stddevPop on columns
"""
type HallOfFameStddevPopFields {
  editionId: Float
  groupsId: Float
  levelId: Float
  levelImageId: Float
  sumOfPoints: Float
  userId: Float
  userImageId: Float
}

"""
aggregate stddevSamp on columns
"""
type HallOfFameStddevSampFields {
  editionId: Float
  groupsId: Float
  levelId: Float
  levelImageId: Float
  sumOfPoints: Float
  userId: Float
  userImageId: Float
}

"""
Streaming cursor of the table "hall_of_fame"
"""
input HallOfFameStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: HallOfFameStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input HallOfFameStreamCursorValueInput {
  editionId: bigint
  groupName: String
  groupsId: bigint
  levelId: bigint
  levelImageId: bigint
  levelName: String
  nick: String
  sumOfPoints: numeric
  userId: bigint
  userImageId: bigint
}

"""
aggregate sum on columns
"""
type HallOfFameSumFields {
  editionId: bigint
  groupsId: bigint
  levelId: bigint
  levelImageId: bigint
  sumOfPoints: numeric
  userId: bigint
  userImageId: bigint
}

"""
aggregate varPop on columns
"""
type HallOfFameVarPopFields {
  editionId: Float
  groupsId: Float
  levelId: Float
  levelImageId: Float
  sumOfPoints: Float
  userId: Float
  userImageId: Float
}

"""
aggregate varSamp on columns
"""
type HallOfFameVarSampFields {
  editionId: Float
  groupsId: Float
  levelId: Float
  levelImageId: Float
  sumOfPoints: Float
  userId: Float
  userImageId: Float
}

"""
aggregate variance on columns
"""
type HallOfFameVarianceFields {
  editionId: Float
  groupsId: Float
  levelId: Float
  levelImageId: Float
  sumOfPoints: Float
  userId: Float
  userImageId: Float
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

type LevelType {
  edition: EditionType!
  grade: String!
  highest: Boolean!
  imageFile: FileType
  label: String!
  levelId: ID!
  levelName: String!
  maximumPoints: String!
  minimumPoints: String!
  ordinalNumber: Int!
  userLevels: [UserLevelType]
}

"""
columns and relationships of "levels"
"""
type Levels {
  """
  An object relationship
  """
  edition: Edition!
  editionId: bigint!

  """
  An object relationship
  """
  file: Files
  grade: numeric!
  highest: Boolean!
  imageFileId: bigint
  label: String!
  levelId: bigint!
  maximumPoints: numeric!
  minimumPoints: numeric!
  name: String!
  ordinalNumber: Int!

  """
  An array relationship
  """
  userLevels(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): [UserLevel!]!

  """
  An aggregate relationship
  """
  userLevelsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): UserLevelAggregate!
}

"""
aggregated selection of "levels"
"""
type LevelsAggregate {
  aggregate: LevelsAggregateFields
  nodes: [Levels!]!
}

input LevelsAggregateBoolExp {
  bool_and: levelsAggregateBoolExpBool_and
  bool_or: levelsAggregateBoolExpBool_or
  count: levelsAggregateBoolExpCount
}

"""
aggregate fields of "levels"
"""
type LevelsAggregateFields {
  avg: LevelsAvgFields
  count(columns: [LevelsSelectColumn!], distinct: Boolean): Int!
  max: LevelsMaxFields
  min: LevelsMinFields
  stddev: LevelsStddevFields
  stddevPop: LevelsStddevPopFields
  stddevSamp: LevelsStddevSampFields
  sum: LevelsSumFields
  varPop: LevelsVarPopFields
  varSamp: LevelsVarSampFields
  variance: LevelsVarianceFields
}

"""
order by aggregate values of table "levels"
"""
input LevelsAggregateOrderBy {
  avg: LevelsAvgOrderBy
  count: OrderBy
  max: LevelsMaxOrderBy
  min: LevelsMinOrderBy
  stddev: LevelsStddevOrderBy
  stddevPop: LevelsStddevPopOrderBy
  stddevSamp: LevelsStddevSampOrderBy
  sum: LevelsSumOrderBy
  varPop: LevelsVarPopOrderBy
  varSamp: LevelsVarSampOrderBy
  variance: LevelsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "levels"
"""
input LevelsArrRelInsertInput {
  data: [LevelsInsertInput!]!

  """
  upsert condition
  """
  onConflict: LevelsOnConflict
}

"""
aggregate avg on columns
"""
type LevelsAvgFields {
  editionId: Float
  grade: Float
  imageFileId: Float
  levelId: Float
  maximumPoints: Float
  minimumPoints: Float
  ordinalNumber: Float
}

"""
order by avg() on columns of table "levels"
"""
input LevelsAvgOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  ordinalNumber: OrderBy
}

"""
Boolean expression to filter rows from the table "levels". All fields are combined with a logical 'AND'.
"""
input LevelsBoolExp {
  _and: [LevelsBoolExp!]
  _not: LevelsBoolExp
  _or: [LevelsBoolExp!]
  edition: EditionBoolExp
  editionId: BigintComparisonExp
  file: FilesBoolExp
  grade: NumericComparisonExp
  highest: BooleanComparisonExp
  imageFileId: BigintComparisonExp
  label: StringComparisonExp
  levelId: BigintComparisonExp
  maximumPoints: NumericComparisonExp
  minimumPoints: NumericComparisonExp
  name: StringComparisonExp
  ordinalNumber: IntComparisonExp
  userLevels: UserLevelBoolExp
  userLevelsAggregate: UserLevelAggregateBoolExp
}

"""
unique or primary key constraints on table "levels"
"""
enum LevelsConstraint {
  """
  unique or primary key constraint on columns "level_id"
  """
  levels_pkey
}

"""
input type for incrementing numeric columns in table "levels"
"""
input LevelsIncInput {
  editionId: bigint
  grade: numeric
  imageFileId: bigint
  levelId: bigint
  maximumPoints: numeric
  minimumPoints: numeric
  ordinalNumber: Int
}

"""
input type for inserting data into table "levels"
"""
input LevelsInsertInput {
  edition: EditionObjRelInsertInput
  editionId: bigint
  file: FilesObjRelInsertInput
  grade: numeric
  highest: Boolean
  imageFileId: bigint
  label: String
  levelId: bigint
  maximumPoints: numeric
  minimumPoints: numeric
  name: String
  ordinalNumber: Int
  userLevels: UserLevelArrRelInsertInput
}

"""
aggregate max on columns
"""
type LevelsMaxFields {
  editionId: bigint
  grade: numeric
  imageFileId: bigint
  label: String
  levelId: bigint
  maximumPoints: numeric
  minimumPoints: numeric
  name: String
  ordinalNumber: Int
}

"""
order by max() on columns of table "levels"
"""
input LevelsMaxOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  name: OrderBy
  ordinalNumber: OrderBy
}

"""
aggregate min on columns
"""
type LevelsMinFields {
  editionId: bigint
  grade: numeric
  imageFileId: bigint
  label: String
  levelId: bigint
  maximumPoints: numeric
  minimumPoints: numeric
  name: String
  ordinalNumber: Int
}

"""
order by min() on columns of table "levels"
"""
input LevelsMinOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  name: OrderBy
  ordinalNumber: OrderBy
}

"""
response of any mutation on the table "levels"
"""
type LevelsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Levels!]!
}

"""
input type for inserting object relation for remote table "levels"
"""
input LevelsObjRelInsertInput {
  data: LevelsInsertInput!

  """
  upsert condition
  """
  onConflict: LevelsOnConflict
}

"""
on_conflict condition type for table "levels"
"""
input LevelsOnConflict {
  constraint: LevelsConstraint!
  updateColumns: [LevelsUpdateColumn!]! = []
  where: LevelsBoolExp
}

"""
Ordering options when selecting data from "levels".
"""
input LevelsOrderBy {
  edition: EditionOrderBy
  editionId: OrderBy
  file: FilesOrderBy
  grade: OrderBy
  highest: OrderBy
  imageFileId: OrderBy
  label: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  name: OrderBy
  ordinalNumber: OrderBy
  userLevelsAggregate: UserLevelAggregateOrderBy
}

"""
primary key columns input for table: levels
"""
input LevelsPkColumnsInput {
  levelId: bigint!
}

"""
select columns of table "levels"
"""
enum LevelsSelectColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  grade

  """
  column name
  """
  highest

  """
  column name
  """
  imageFileId

  """
  column name
  """
  label

  """
  column name
  """
  levelId

  """
  column name
  """
  maximumPoints

  """
  column name
  """
  minimumPoints

  """
  column name
  """
  name

  """
  column name
  """
  ordinalNumber
}

"""
select "levelsAggregateBoolExpBool_andArgumentsColumns" columns of table "levels"
"""
enum LevelsSelectColumnLevelsAggregateBoolExpBool_andArgumentsColumns {
  """
  column name
  """
  highest
}

"""
select "levelsAggregateBoolExpBool_orArgumentsColumns" columns of table "levels"
"""
enum LevelsSelectColumnLevelsAggregateBoolExpBool_orArgumentsColumns {
  """
  column name
  """
  highest
}

"""
input type for updating data in table "levels"
"""
input LevelsSetInput {
  editionId: bigint
  grade: numeric
  highest: Boolean
  imageFileId: bigint
  label: String
  levelId: bigint
  maximumPoints: numeric
  minimumPoints: numeric
  name: String
  ordinalNumber: Int
}

"""
aggregate stddev on columns
"""
type LevelsStddevFields {
  editionId: Float
  grade: Float
  imageFileId: Float
  levelId: Float
  maximumPoints: Float
  minimumPoints: Float
  ordinalNumber: Float
}

"""
order by stddev() on columns of table "levels"
"""
input LevelsStddevOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  ordinalNumber: OrderBy
}

"""
aggregate stddevPop on columns
"""
type LevelsStddevPopFields {
  editionId: Float
  grade: Float
  imageFileId: Float
  levelId: Float
  maximumPoints: Float
  minimumPoints: Float
  ordinalNumber: Float
}

"""
order by stddevPop() on columns of table "levels"
"""
input LevelsStddevPopOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  ordinalNumber: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type LevelsStddevSampFields {
  editionId: Float
  grade: Float
  imageFileId: Float
  levelId: Float
  maximumPoints: Float
  minimumPoints: Float
  ordinalNumber: Float
}

"""
order by stddevSamp() on columns of table "levels"
"""
input LevelsStddevSampOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  ordinalNumber: OrderBy
}

"""
Streaming cursor of the table "levels"
"""
input LevelsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: LevelsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input LevelsStreamCursorValueInput {
  editionId: bigint
  grade: numeric
  highest: Boolean
  imageFileId: bigint
  label: String
  levelId: bigint
  maximumPoints: numeric
  minimumPoints: numeric
  name: String
  ordinalNumber: Int
}

"""
aggregate sum on columns
"""
type LevelsSumFields {
  editionId: bigint
  grade: numeric
  imageFileId: bigint
  levelId: bigint
  maximumPoints: numeric
  minimumPoints: numeric
  ordinalNumber: Int
}

"""
order by sum() on columns of table "levels"
"""
input LevelsSumOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  ordinalNumber: OrderBy
}

"""
update columns of table "levels"
"""
enum LevelsUpdateColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  grade

  """
  column name
  """
  highest

  """
  column name
  """
  imageFileId

  """
  column name
  """
  label

  """
  column name
  """
  levelId

  """
  column name
  """
  maximumPoints

  """
  column name
  """
  minimumPoints

  """
  column name
  """
  name

  """
  column name
  """
  ordinalNumber
}

input LevelsUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: LevelsIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: LevelsSetInput

  """
  filter the rows which have to be updated
  """
  where: LevelsBoolExp!
}

"""
aggregate varPop on columns
"""
type LevelsVarPopFields {
  editionId: Float
  grade: Float
  imageFileId: Float
  levelId: Float
  maximumPoints: Float
  minimumPoints: Float
  ordinalNumber: Float
}

"""
order by varPop() on columns of table "levels"
"""
input LevelsVarPopOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  ordinalNumber: OrderBy
}

"""
aggregate varSamp on columns
"""
type LevelsVarSampFields {
  editionId: Float
  grade: Float
  imageFileId: Float
  levelId: Float
  maximumPoints: Float
  minimumPoints: Float
  ordinalNumber: Float
}

"""
order by varSamp() on columns of table "levels"
"""
input LevelsVarSampOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  ordinalNumber: OrderBy
}

"""
aggregate variance on columns
"""
type LevelsVarianceFields {
  editionId: Float
  grade: Float
  imageFileId: Float
  levelId: Float
  maximumPoints: Float
  minimumPoints: Float
  ordinalNumber: Float
}

"""
order by variance() on columns of table "levels"
"""
input LevelsVarianceOrderBy {
  editionId: OrderBy
  grade: OrderBy
  imageFileId: OrderBy
  levelId: OrderBy
  maximumPoints: OrderBy
  minimumPoints: OrderBy
  ordinalNumber: OrderBy
}

type NeighboringLevelsType {
  currLevel: LevelType!
  nextLevel: LevelType
  prevLevel: LevelType
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input NumericComparisonExp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _isNull: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
column ordering options
"""
enum OrderBy {
  """
  in ascending order, nulls last
  """
  ASC

  """
  in ascending order, nulls first
  """
  ASC_NULLS_FIRST

  """
  in ascending order, nulls last
  """
  ASC_NULLS_LAST

  """
  in descending order, nulls first
  """
  DESC

  """
  in descending order, nulls first
  """
  DESC_NULLS_FIRST

  """
  in descending order, nulls last
  """
  DESC_NULLS_LAST
}

type PartialBonusType {
  bonuses: BonusType!
  partialValue: Float!
}

type PointType {
  createdAt: String!
  label: String!
  pointsId: ID!
  student: UserType!
  subcategory: SubcategoryType!
  teacher: UserType!
  updatedAt: String!
  updatedBy: UserType!
  value: String!
}

"""
columns and relationships of "points"
"""
type Points {
  """
  An array relationship
  """
  bonuses(
    """
    distinct select on columns
    """
    distinctOn: [BonusesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BonusesOrderBy!]

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): [Bonuses!]!

  """
  An aggregate relationship
  """
  bonusesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [BonusesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BonusesOrderBy!]

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): BonusesAggregate!
  createdAt: timestamp!
  label: String!
  pointsId: bigint!
  studentId: bigint!

  """
  An object relationship
  """
  subcategory: Subcategories!
  subcategoryId: bigint!
  teacherId: bigint!
  updatedAt: timestamp!
  updatedBy: bigint!

  """
  An object relationship
  """
  user: Users!

  """
  An object relationship
  """
  userByTeacherId: Users!

  """
  An object relationship
  """
  userByUpdatedBy: Users!
  value: numeric!
}

"""
aggregated selection of "points"
"""
type PointsAggregate {
  aggregate: PointsAggregateFields
  nodes: [Points!]!
}

input PointsAggregateBoolExp {
  count: pointsAggregateBoolExpCount
}

"""
aggregate fields of "points"
"""
type PointsAggregateFields {
  avg: PointsAvgFields
  count(columns: [PointsSelectColumn!], distinct: Boolean): Int!
  max: PointsMaxFields
  min: PointsMinFields
  stddev: PointsStddevFields
  stddevPop: PointsStddevPopFields
  stddevSamp: PointsStddevSampFields
  sum: PointsSumFields
  varPop: PointsVarPopFields
  varSamp: PointsVarSampFields
  variance: PointsVarianceFields
}

"""
order by aggregate values of table "points"
"""
input PointsAggregateOrderBy {
  avg: PointsAvgOrderBy
  count: OrderBy
  max: PointsMaxOrderBy
  min: PointsMinOrderBy
  stddev: PointsStddevOrderBy
  stddevPop: PointsStddevPopOrderBy
  stddevSamp: PointsStddevSampOrderBy
  sum: PointsSumOrderBy
  varPop: PointsVarPopOrderBy
  varSamp: PointsVarSampOrderBy
  variance: PointsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "points"
"""
input PointsArrRelInsertInput {
  data: [PointsInsertInput!]!

  """
  upsert condition
  """
  onConflict: PointsOnConflict
}

"""
aggregate avg on columns
"""
type PointsAvgFields {
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by avg() on columns of table "points"
"""
input PointsAvgOrderBy {
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
Boolean expression to filter rows from the table "points". All fields are combined with a logical 'AND'.
"""
input PointsBoolExp {
  _and: [PointsBoolExp!]
  _not: PointsBoolExp
  _or: [PointsBoolExp!]
  bonuses: BonusesBoolExp
  bonusesAggregate: BonusesAggregateBoolExp
  createdAt: TimestampComparisonExp
  label: StringComparisonExp
  pointsId: BigintComparisonExp
  studentId: BigintComparisonExp
  subcategory: SubcategoriesBoolExp
  subcategoryId: BigintComparisonExp
  teacherId: BigintComparisonExp
  updatedAt: TimestampComparisonExp
  updatedBy: BigintComparisonExp
  user: UsersBoolExp
  userByTeacherId: UsersBoolExp
  userByUpdatedBy: UsersBoolExp
  value: NumericComparisonExp
}

"""
unique or primary key constraints on table "points"
"""
enum PointsConstraint {
  """
  unique or primary key constraint on columns "points_id"
  """
  points_pkey
}

"""
columns and relationships of "points_history"
"""
type PointsHistory {
  copiedAt: timestamp!
  createdAt: timestamp!
  label: String!

  """
  An object relationship
  """
  points: Points
  pointsHistoryId: bigint!
  pointsId: bigint!
  studentId: bigint!

  """
  An object relationship
  """
  subcategory: Subcategories!
  subcategoryId: bigint!
  teacherId: bigint!
  updatedAt: timestamp!
  updatedBy: bigint!

  """
  An object relationship
  """
  user: Users!

  """
  An object relationship
  """
  userByTeacherId: Users!
  value: Float!
}

"""
aggregated selection of "points_history"
"""
type PointsHistoryAggregate {
  aggregate: PointsHistoryAggregateFields
  nodes: [PointsHistory!]!
}

input PointsHistoryAggregateBoolExp {
  count: pointsHistoryAggregateBoolExpCount
}

"""
aggregate fields of "points_history"
"""
type PointsHistoryAggregateFields {
  avg: PointsHistoryAvgFields
  count(columns: [PointsHistorySelectColumn!], distinct: Boolean): Int!
  max: PointsHistoryMaxFields
  min: PointsHistoryMinFields
  stddev: PointsHistoryStddevFields
  stddevPop: PointsHistoryStddevPopFields
  stddevSamp: PointsHistoryStddevSampFields
  sum: PointsHistorySumFields
  varPop: PointsHistoryVarPopFields
  varSamp: PointsHistoryVarSampFields
  variance: PointsHistoryVarianceFields
}

"""
order by aggregate values of table "points_history"
"""
input PointsHistoryAggregateOrderBy {
  avg: PointsHistoryAvgOrderBy
  count: OrderBy
  max: PointsHistoryMaxOrderBy
  min: PointsHistoryMinOrderBy
  stddev: PointsHistoryStddevOrderBy
  stddevPop: PointsHistoryStddevPopOrderBy
  stddevSamp: PointsHistoryStddevSampOrderBy
  sum: PointsHistorySumOrderBy
  varPop: PointsHistoryVarPopOrderBy
  varSamp: PointsHistoryVarSampOrderBy
  variance: PointsHistoryVarianceOrderBy
}

"""
input type for inserting array relation for remote table "points_history"
"""
input PointsHistoryArrRelInsertInput {
  data: [PointsHistoryInsertInput!]!

  """
  upsert condition
  """
  onConflict: PointsHistoryOnConflict
}

"""
aggregate avg on columns
"""
type PointsHistoryAvgFields {
  pointsHistoryId: Float
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by avg() on columns of table "points_history"
"""
input PointsHistoryAvgOrderBy {
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
Boolean expression to filter rows from the table "points_history". All fields are combined with a logical 'AND'.
"""
input PointsHistoryBoolExp {
  _and: [PointsHistoryBoolExp!]
  _not: PointsHistoryBoolExp
  _or: [PointsHistoryBoolExp!]
  copiedAt: TimestampComparisonExp
  createdAt: TimestampComparisonExp
  label: StringComparisonExp
  points: PointsBoolExp
  pointsHistoryId: BigintComparisonExp
  pointsId: BigintComparisonExp
  studentId: BigintComparisonExp
  subcategory: SubcategoriesBoolExp
  subcategoryId: BigintComparisonExp
  teacherId: BigintComparisonExp
  updatedAt: TimestampComparisonExp
  updatedBy: BigintComparisonExp
  user: UsersBoolExp
  userByTeacherId: UsersBoolExp
  value: FloatComparisonExp
}

"""
unique or primary key constraints on table "points_history"
"""
enum PointsHistoryConstraint {
  """
  unique or primary key constraint on columns "points_history_id"
  """
  points_history_pkey
}

"""
input type for incrementing numeric columns in table "points_history"
"""
input PointsHistoryIncInput {
  pointsHistoryId: bigint
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedBy: bigint
  value: Float
}

"""
input type for inserting data into table "points_history"
"""
input PointsHistoryInsertInput {
  copiedAt: timestamp
  createdAt: timestamp
  label: String
  points: PointsObjRelInsertInput
  pointsHistoryId: bigint
  pointsId: bigint
  studentId: bigint
  subcategory: SubcategoriesObjRelInsertInput
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  user: UsersObjRelInsertInput
  userByTeacherId: UsersObjRelInsertInput
  value: Float
}

"""
aggregate max on columns
"""
type PointsHistoryMaxFields {
  copiedAt: timestamp
  createdAt: timestamp
  label: String
  pointsHistoryId: bigint
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  value: Float
}

"""
order by max() on columns of table "points_history"
"""
input PointsHistoryMaxOrderBy {
  copiedAt: OrderBy
  createdAt: OrderBy
  label: OrderBy
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate min on columns
"""
type PointsHistoryMinFields {
  copiedAt: timestamp
  createdAt: timestamp
  label: String
  pointsHistoryId: bigint
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  value: Float
}

"""
order by min() on columns of table "points_history"
"""
input PointsHistoryMinOrderBy {
  copiedAt: OrderBy
  createdAt: OrderBy
  label: OrderBy
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
response of any mutation on the table "points_history"
"""
type PointsHistoryMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [PointsHistory!]!
}

"""
on_conflict condition type for table "points_history"
"""
input PointsHistoryOnConflict {
  constraint: PointsHistoryConstraint!
  updateColumns: [PointsHistoryUpdateColumn!]! = []
  where: PointsHistoryBoolExp
}

"""
Ordering options when selecting data from "points_history".
"""
input PointsHistoryOrderBy {
  copiedAt: OrderBy
  createdAt: OrderBy
  label: OrderBy
  points: PointsOrderBy
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategory: SubcategoriesOrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  user: UsersOrderBy
  userByTeacherId: UsersOrderBy
  value: OrderBy
}

"""
primary key columns input for table: points_history
"""
input PointsHistoryPkColumnsInput {
  pointsHistoryId: bigint!
}

"""
select columns of table "points_history"
"""
enum PointsHistorySelectColumn {
  """
  column name
  """
  copiedAt

  """
  column name
  """
  createdAt

  """
  column name
  """
  label

  """
  column name
  """
  pointsHistoryId

  """
  column name
  """
  pointsId

  """
  column name
  """
  studentId

  """
  column name
  """
  subcategoryId

  """
  column name
  """
  teacherId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedBy

  """
  column name
  """
  value
}

"""
input type for updating data in table "points_history"
"""
input PointsHistorySetInput {
  copiedAt: timestamp
  createdAt: timestamp
  label: String
  pointsHistoryId: bigint
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  value: Float
}

"""
aggregate stddev on columns
"""
type PointsHistoryStddevFields {
  pointsHistoryId: Float
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by stddev() on columns of table "points_history"
"""
input PointsHistoryStddevOrderBy {
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate stddevPop on columns
"""
type PointsHistoryStddevPopFields {
  pointsHistoryId: Float
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by stddevPop() on columns of table "points_history"
"""
input PointsHistoryStddevPopOrderBy {
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type PointsHistoryStddevSampFields {
  pointsHistoryId: Float
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by stddevSamp() on columns of table "points_history"
"""
input PointsHistoryStddevSampOrderBy {
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
Streaming cursor of the table "points_history"
"""
input PointsHistoryStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: PointsHistoryStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input PointsHistoryStreamCursorValueInput {
  copiedAt: timestamp
  createdAt: timestamp
  label: String
  pointsHistoryId: bigint
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  value: Float
}

"""
aggregate sum on columns
"""
type PointsHistorySumFields {
  pointsHistoryId: bigint
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedBy: bigint
  value: Float
}

"""
order by sum() on columns of table "points_history"
"""
input PointsHistorySumOrderBy {
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
update columns of table "points_history"
"""
enum PointsHistoryUpdateColumn {
  """
  column name
  """
  copiedAt

  """
  column name
  """
  createdAt

  """
  column name
  """
  label

  """
  column name
  """
  pointsHistoryId

  """
  column name
  """
  pointsId

  """
  column name
  """
  studentId

  """
  column name
  """
  subcategoryId

  """
  column name
  """
  teacherId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedBy

  """
  column name
  """
  value
}

input PointsHistoryUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: PointsHistoryIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: PointsHistorySetInput

  """
  filter the rows which have to be updated
  """
  where: PointsHistoryBoolExp!
}

"""
aggregate varPop on columns
"""
type PointsHistoryVarPopFields {
  pointsHistoryId: Float
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by varPop() on columns of table "points_history"
"""
input PointsHistoryVarPopOrderBy {
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate varSamp on columns
"""
type PointsHistoryVarSampFields {
  pointsHistoryId: Float
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by varSamp() on columns of table "points_history"
"""
input PointsHistoryVarSampOrderBy {
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate variance on columns
"""
type PointsHistoryVarianceFields {
  pointsHistoryId: Float
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by variance() on columns of table "points_history"
"""
input PointsHistoryVarianceOrderBy {
  pointsHistoryId: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
input type for incrementing numeric columns in table "points"
"""
input PointsIncInput {
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedBy: bigint
  value: numeric
}

"""
input type for inserting data into table "points"
"""
input PointsInsertInput {
  bonuses: BonusesArrRelInsertInput
  createdAt: timestamp
  label: String
  pointsId: bigint
  studentId: bigint
  subcategory: SubcategoriesObjRelInsertInput
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  user: UsersObjRelInsertInput
  userByTeacherId: UsersObjRelInsertInput
  userByUpdatedBy: UsersObjRelInsertInput
  value: numeric
}

"""
aggregate max on columns
"""
type PointsMaxFields {
  createdAt: timestamp
  label: String
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  value: numeric
}

"""
order by max() on columns of table "points"
"""
input PointsMaxOrderBy {
  createdAt: OrderBy
  label: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate min on columns
"""
type PointsMinFields {
  createdAt: timestamp
  label: String
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  value: numeric
}

"""
order by min() on columns of table "points"
"""
input PointsMinOrderBy {
  createdAt: OrderBy
  label: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
response of any mutation on the table "points"
"""
type PointsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Points!]!
}

"""
input type for inserting object relation for remote table "points"
"""
input PointsObjRelInsertInput {
  data: PointsInsertInput!

  """
  upsert condition
  """
  onConflict: PointsOnConflict
}

"""
on_conflict condition type for table "points"
"""
input PointsOnConflict {
  constraint: PointsConstraint!
  updateColumns: [PointsUpdateColumn!]! = []
  where: PointsBoolExp
}

"""
Ordering options when selecting data from "points".
"""
input PointsOrderBy {
  bonusesAggregate: BonusesAggregateOrderBy
  createdAt: OrderBy
  label: OrderBy
  pointsId: OrderBy
  studentId: OrderBy
  subcategory: SubcategoriesOrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  user: UsersOrderBy
  userByTeacherId: UsersOrderBy
  userByUpdatedBy: UsersOrderBy
  value: OrderBy
}

"""
primary key columns input for table: points
"""
input PointsPkColumnsInput {
  pointsId: bigint!
}

"""
select columns of table "points"
"""
enum PointsSelectColumn {
  """
  column name
  """
  createdAt

  """
  column name
  """
  label

  """
  column name
  """
  pointsId

  """
  column name
  """
  studentId

  """
  column name
  """
  subcategoryId

  """
  column name
  """
  teacherId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedBy

  """
  column name
  """
  value
}

"""
input type for updating data in table "points"
"""
input PointsSetInput {
  createdAt: timestamp
  label: String
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  value: numeric
}

"""
aggregate stddev on columns
"""
type PointsStddevFields {
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by stddev() on columns of table "points"
"""
input PointsStddevOrderBy {
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate stddevPop on columns
"""
type PointsStddevPopFields {
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by stddevPop() on columns of table "points"
"""
input PointsStddevPopOrderBy {
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type PointsStddevSampFields {
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by stddevSamp() on columns of table "points"
"""
input PointsStddevSampOrderBy {
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
Streaming cursor of the table "points"
"""
input PointsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: PointsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input PointsStreamCursorValueInput {
  createdAt: timestamp
  label: String
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedAt: timestamp
  updatedBy: bigint
  value: numeric
}

"""
aggregate sum on columns
"""
type PointsSumFields {
  pointsId: bigint
  studentId: bigint
  subcategoryId: bigint
  teacherId: bigint
  updatedBy: bigint
  value: numeric
}

"""
order by sum() on columns of table "points"
"""
input PointsSumOrderBy {
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
update columns of table "points"
"""
enum PointsUpdateColumn {
  """
  column name
  """
  createdAt

  """
  column name
  """
  label

  """
  column name
  """
  pointsId

  """
  column name
  """
  studentId

  """
  column name
  """
  subcategoryId

  """
  column name
  """
  teacherId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedBy

  """
  column name
  """
  value
}

input PointsUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: PointsIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: PointsSetInput

  """
  filter the rows which have to be updated
  """
  where: PointsBoolExp!
}

"""
aggregate varPop on columns
"""
type PointsVarPopFields {
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by varPop() on columns of table "points"
"""
input PointsVarPopOrderBy {
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate varSamp on columns
"""
type PointsVarSampFields {
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by varSamp() on columns of table "points"
"""
input PointsVarSampOrderBy {
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

"""
aggregate variance on columns
"""
type PointsVarianceFields {
  pointsId: Float
  studentId: Float
  subcategoryId: Float
  teacherId: Float
  updatedBy: Float
  value: Float
}

"""
order by variance() on columns of table "points"
"""
input PointsVarianceOrderBy {
  pointsId: OrderBy
  studentId: OrderBy
  subcategoryId: OrderBy
  teacherId: OrderBy
  updatedBy: OrderBy
  value: OrderBy
}

type PurePointsType {
  partialBonusType: [PartialBonusType]!
  purePoints: PointType
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

type StudentPointsType {
  level: LevelType
  subcategoryPoints: [SubcategoryPointsType!]!
  sumOfAll: Float!
  sumOfBonuses: Float!
  sumOfPurePoints: Float!
  teacher: UserType!
  user: UserType!
}

"""
columns and relationships of "subcategories"
"""
type Subcategories {
  """
  An object relationship
  """
  category: Categories!
  categoryId: bigint!

  """
  An array relationship
  """
  chestHistories(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): [ChestHistory!]!

  """
  An aggregate relationship
  """
  chestHistoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): ChestHistoryAggregate!

  """
  An object relationship
  """
  edition: Edition!
  editionId: bigint!
  label: String!
  maxPoints: numeric!
  ordinalNumber: Int!

  """
  An array relationship
  """
  points(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): [Points!]!

  """
  An aggregate relationship
  """
  pointsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): PointsAggregate!

  """
  An array relationship
  """
  pointsHistories(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): [PointsHistory!]!

  """
  An aggregate relationship
  """
  pointsHistoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): PointsHistoryAggregate!
  subcategoryId: bigint!
  subcategoryName: String!
}

"""
aggregated selection of "subcategories"
"""
type SubcategoriesAggregate {
  aggregate: SubcategoriesAggregateFields
  nodes: [Subcategories!]!
}

input SubcategoriesAggregateBoolExp {
  count: subcategoriesAggregateBoolExpCount
}

"""
aggregate fields of "subcategories"
"""
type SubcategoriesAggregateFields {
  avg: SubcategoriesAvgFields
  count(columns: [SubcategoriesSelectColumn!], distinct: Boolean): Int!
  max: SubcategoriesMaxFields
  min: SubcategoriesMinFields
  stddev: SubcategoriesStddevFields
  stddevPop: SubcategoriesStddevPopFields
  stddevSamp: SubcategoriesStddevSampFields
  sum: SubcategoriesSumFields
  varPop: SubcategoriesVarPopFields
  varSamp: SubcategoriesVarSampFields
  variance: SubcategoriesVarianceFields
}

"""
order by aggregate values of table "subcategories"
"""
input SubcategoriesAggregateOrderBy {
  avg: SubcategoriesAvgOrderBy
  count: OrderBy
  max: SubcategoriesMaxOrderBy
  min: SubcategoriesMinOrderBy
  stddev: SubcategoriesStddevOrderBy
  stddevPop: SubcategoriesStddevPopOrderBy
  stddevSamp: SubcategoriesStddevSampOrderBy
  sum: SubcategoriesSumOrderBy
  varPop: SubcategoriesVarPopOrderBy
  varSamp: SubcategoriesVarSampOrderBy
  variance: SubcategoriesVarianceOrderBy
}

"""
input type for inserting array relation for remote table "subcategories"
"""
input SubcategoriesArrRelInsertInput {
  data: [SubcategoriesInsertInput!]!

  """
  upsert condition
  """
  onConflict: SubcategoriesOnConflict
}

"""
aggregate avg on columns
"""
type SubcategoriesAvgFields {
  categoryId: Float
  editionId: Float
  maxPoints: Float
  ordinalNumber: Float
  subcategoryId: Float
}

"""
order by avg() on columns of table "subcategories"
"""
input SubcategoriesAvgOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
}

"""
Boolean expression to filter rows from the table "subcategories". All fields are combined with a logical 'AND'.
"""
input SubcategoriesBoolExp {
  _and: [SubcategoriesBoolExp!]
  _not: SubcategoriesBoolExp
  _or: [SubcategoriesBoolExp!]
  category: CategoriesBoolExp
  categoryId: BigintComparisonExp
  chestHistories: ChestHistoryBoolExp
  chestHistoriesAggregate: ChestHistoryAggregateBoolExp
  edition: EditionBoolExp
  editionId: BigintComparisonExp
  label: StringComparisonExp
  maxPoints: NumericComparisonExp
  ordinalNumber: IntComparisonExp
  points: PointsBoolExp
  pointsAggregate: PointsAggregateBoolExp
  pointsHistories: PointsHistoryBoolExp
  pointsHistoriesAggregate: PointsHistoryAggregateBoolExp
  subcategoryId: BigintComparisonExp
  subcategoryName: StringComparisonExp
}

"""
unique or primary key constraints on table "subcategories"
"""
enum SubcategoriesConstraint {
  """
  unique or primary key constraint on columns "subcategory_id"
  """
  subcategories_pkey
}

"""
input type for incrementing numeric columns in table "subcategories"
"""
input SubcategoriesIncInput {
  categoryId: bigint
  editionId: bigint
  maxPoints: numeric
  ordinalNumber: Int
  subcategoryId: bigint
}

"""
input type for inserting data into table "subcategories"
"""
input SubcategoriesInsertInput {
  category: CategoriesObjRelInsertInput
  categoryId: bigint
  chestHistories: ChestHistoryArrRelInsertInput
  edition: EditionObjRelInsertInput
  editionId: bigint
  label: String
  maxPoints: numeric
  ordinalNumber: Int
  points: PointsArrRelInsertInput
  pointsHistories: PointsHistoryArrRelInsertInput
  subcategoryId: bigint
  subcategoryName: String
}

"""
aggregate max on columns
"""
type SubcategoriesMaxFields {
  categoryId: bigint
  editionId: bigint
  label: String
  maxPoints: numeric
  ordinalNumber: Int
  subcategoryId: bigint
  subcategoryName: String
}

"""
order by max() on columns of table "subcategories"
"""
input SubcategoriesMaxOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  label: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
  subcategoryName: OrderBy
}

"""
aggregate min on columns
"""
type SubcategoriesMinFields {
  categoryId: bigint
  editionId: bigint
  label: String
  maxPoints: numeric
  ordinalNumber: Int
  subcategoryId: bigint
  subcategoryName: String
}

"""
order by min() on columns of table "subcategories"
"""
input SubcategoriesMinOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  label: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
  subcategoryName: OrderBy
}

"""
response of any mutation on the table "subcategories"
"""
type SubcategoriesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Subcategories!]!
}

"""
input type for inserting object relation for remote table "subcategories"
"""
input SubcategoriesObjRelInsertInput {
  data: SubcategoriesInsertInput!

  """
  upsert condition
  """
  onConflict: SubcategoriesOnConflict
}

"""
on_conflict condition type for table "subcategories"
"""
input SubcategoriesOnConflict {
  constraint: SubcategoriesConstraint!
  updateColumns: [SubcategoriesUpdateColumn!]! = []
  where: SubcategoriesBoolExp
}

"""
Ordering options when selecting data from "subcategories".
"""
input SubcategoriesOrderBy {
  category: CategoriesOrderBy
  categoryId: OrderBy
  chestHistoriesAggregate: ChestHistoryAggregateOrderBy
  edition: EditionOrderBy
  editionId: OrderBy
  label: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  pointsAggregate: PointsAggregateOrderBy
  pointsHistoriesAggregate: PointsHistoryAggregateOrderBy
  subcategoryId: OrderBy
  subcategoryName: OrderBy
}

"""
primary key columns input for table: subcategories
"""
input SubcategoriesPkColumnsInput {
  subcategoryId: bigint!
}

"""
select columns of table "subcategories"
"""
enum SubcategoriesSelectColumn {
  """
  column name
  """
  categoryId

  """
  column name
  """
  editionId

  """
  column name
  """
  label

  """
  column name
  """
  maxPoints

  """
  column name
  """
  ordinalNumber

  """
  column name
  """
  subcategoryId

  """
  column name
  """
  subcategoryName
}

"""
input type for updating data in table "subcategories"
"""
input SubcategoriesSetInput {
  categoryId: bigint
  editionId: bigint
  label: String
  maxPoints: numeric
  ordinalNumber: Int
  subcategoryId: bigint
  subcategoryName: String
}

"""
aggregate stddev on columns
"""
type SubcategoriesStddevFields {
  categoryId: Float
  editionId: Float
  maxPoints: Float
  ordinalNumber: Float
  subcategoryId: Float
}

"""
order by stddev() on columns of table "subcategories"
"""
input SubcategoriesStddevOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type SubcategoriesStddevPopFields {
  categoryId: Float
  editionId: Float
  maxPoints: Float
  ordinalNumber: Float
  subcategoryId: Float
}

"""
order by stddevPop() on columns of table "subcategories"
"""
input SubcategoriesStddevPopOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type SubcategoriesStddevSampFields {
  categoryId: Float
  editionId: Float
  maxPoints: Float
  ordinalNumber: Float
  subcategoryId: Float
}

"""
order by stddevSamp() on columns of table "subcategories"
"""
input SubcategoriesStddevSampOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
}

"""
Streaming cursor of the table "subcategories"
"""
input SubcategoriesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: SubcategoriesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input SubcategoriesStreamCursorValueInput {
  categoryId: bigint
  editionId: bigint
  label: String
  maxPoints: numeric
  ordinalNumber: Int
  subcategoryId: bigint
  subcategoryName: String
}

"""
aggregate sum on columns
"""
type SubcategoriesSumFields {
  categoryId: bigint
  editionId: bigint
  maxPoints: numeric
  ordinalNumber: Int
  subcategoryId: bigint
}

"""
order by sum() on columns of table "subcategories"
"""
input SubcategoriesSumOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
}

"""
update columns of table "subcategories"
"""
enum SubcategoriesUpdateColumn {
  """
  column name
  """
  categoryId

  """
  column name
  """
  editionId

  """
  column name
  """
  label

  """
  column name
  """
  maxPoints

  """
  column name
  """
  ordinalNumber

  """
  column name
  """
  subcategoryId

  """
  column name
  """
  subcategoryName
}

input SubcategoriesUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: SubcategoriesIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: SubcategoriesSetInput

  """
  filter the rows which have to be updated
  """
  where: SubcategoriesBoolExp!
}

"""
aggregate varPop on columns
"""
type SubcategoriesVarPopFields {
  categoryId: Float
  editionId: Float
  maxPoints: Float
  ordinalNumber: Float
  subcategoryId: Float
}

"""
order by varPop() on columns of table "subcategories"
"""
input SubcategoriesVarPopOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
}

"""
aggregate varSamp on columns
"""
type SubcategoriesVarSampFields {
  categoryId: Float
  editionId: Float
  maxPoints: Float
  ordinalNumber: Float
  subcategoryId: Float
}

"""
order by varSamp() on columns of table "subcategories"
"""
input SubcategoriesVarSampOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
}

"""
aggregate variance on columns
"""
type SubcategoriesVarianceFields {
  categoryId: Float
  editionId: Float
  maxPoints: Float
  ordinalNumber: Float
  subcategoryId: Float
}

"""
order by variance() on columns of table "subcategories"
"""
input SubcategoriesVarianceOrderBy {
  categoryId: OrderBy
  editionId: OrderBy
  maxPoints: OrderBy
  ordinalNumber: OrderBy
  subcategoryId: OrderBy
}

type SubcategoryPointsType {
  createdAt: String!
  points: PurePointsType!
  subcategory: SubcategoryType!
  teacher: UserType!
  updatedAt: String!
}

type SubcategoryType {
  category: CategoryType!
  edition: EditionType!
  label: String!
  maxPoints: String!
  ordinalNumber: Int!
  subcategoryId: ID!
  subcategoryName: String!
}

"""
Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'.
"""
input TimeComparisonExp {
  _eq: time
  _gt: time
  _gte: time
  _in: [time!]
  _isNull: Boolean
  _lt: time
  _lte: time
  _neq: time
  _nin: [time!]
}

type TimeSpansType {
  endTime: String!
  startTime: String!
}

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input TimestampComparisonExp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _isNull: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

type UserGroupType {
  group: GroupType!
  user: UserType!
  userGroupsId: ID!
}

"""
columns and relationships of "user_groups"
"""
type UserGroups {
  """
  An object relationship
  """
  group: Groups!
  groupId: bigint!

  """
  An object relationship
  """
  user: Users!
  userId: bigint!
}

"""
aggregated selection of "user_groups"
"""
type UserGroupsAggregate {
  aggregate: UserGroupsAggregateFields
  nodes: [UserGroups!]!
}

input UserGroupsAggregateBoolExp {
  count: userGroupsAggregateBoolExpCount
}

"""
aggregate fields of "user_groups"
"""
type UserGroupsAggregateFields {
  avg: UserGroupsAvgFields
  count(columns: [UserGroupsSelectColumn!], distinct: Boolean): Int!
  max: UserGroupsMaxFields
  min: UserGroupsMinFields
  stddev: UserGroupsStddevFields
  stddevPop: UserGroupsStddevPopFields
  stddevSamp: UserGroupsStddevSampFields
  sum: UserGroupsSumFields
  varPop: UserGroupsVarPopFields
  varSamp: UserGroupsVarSampFields
  variance: UserGroupsVarianceFields
}

"""
order by aggregate values of table "user_groups"
"""
input UserGroupsAggregateOrderBy {
  avg: UserGroupsAvgOrderBy
  count: OrderBy
  max: UserGroupsMaxOrderBy
  min: UserGroupsMinOrderBy
  stddev: UserGroupsStddevOrderBy
  stddevPop: UserGroupsStddevPopOrderBy
  stddevSamp: UserGroupsStddevSampOrderBy
  sum: UserGroupsSumOrderBy
  varPop: UserGroupsVarPopOrderBy
  varSamp: UserGroupsVarSampOrderBy
  variance: UserGroupsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "user_groups"
"""
input UserGroupsArrRelInsertInput {
  data: [UserGroupsInsertInput!]!

  """
  upsert condition
  """
  onConflict: UserGroupsOnConflict
}

"""
aggregate avg on columns
"""
type UserGroupsAvgFields {
  groupId: Float
  userId: Float
}

"""
order by avg() on columns of table "user_groups"
"""
input UserGroupsAvgOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
Boolean expression to filter rows from the table "user_groups". All fields are combined with a logical 'AND'.
"""
input UserGroupsBoolExp {
  _and: [UserGroupsBoolExp!]
  _not: UserGroupsBoolExp
  _or: [UserGroupsBoolExp!]
  group: GroupsBoolExp
  groupId: BigintComparisonExp
  user: UsersBoolExp
  userId: BigintComparisonExp
}

"""
unique or primary key constraints on table "user_groups"
"""
enum UserGroupsConstraint {
  """
  unique or primary key constraint on columns "user_id", "group_id"
  """
  user_groups_pkey
}

"""
input type for incrementing numeric columns in table "user_groups"
"""
input UserGroupsIncInput {
  groupId: bigint
  userId: bigint
}

"""
input type for inserting data into table "user_groups"
"""
input UserGroupsInsertInput {
  group: GroupsObjRelInsertInput
  groupId: bigint
  user: UsersObjRelInsertInput
  userId: bigint
}

"""
aggregate max on columns
"""
type UserGroupsMaxFields {
  groupId: bigint
  userId: bigint
}

"""
order by max() on columns of table "user_groups"
"""
input UserGroupsMaxOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
aggregate min on columns
"""
type UserGroupsMinFields {
  groupId: bigint
  userId: bigint
}

"""
order by min() on columns of table "user_groups"
"""
input UserGroupsMinOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_groups"
"""
type UserGroupsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [UserGroups!]!
}

"""
on_conflict condition type for table "user_groups"
"""
input UserGroupsOnConflict {
  constraint: UserGroupsConstraint!
  updateColumns: [UserGroupsUpdateColumn!]! = []
  where: UserGroupsBoolExp
}

"""
Ordering options when selecting data from "user_groups".
"""
input UserGroupsOrderBy {
  group: GroupsOrderBy
  groupId: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: user_groups
"""
input UserGroupsPkColumnsInput {
  groupId: bigint!
  userId: bigint!
}

"""
select columns of table "user_groups"
"""
enum UserGroupsSelectColumn {
  """
  column name
  """
  groupId

  """
  column name
  """
  userId
}

"""
input type for updating data in table "user_groups"
"""
input UserGroupsSetInput {
  groupId: bigint
  userId: bigint
}

"""
aggregate stddev on columns
"""
type UserGroupsStddevFields {
  groupId: Float
  userId: Float
}

"""
order by stddev() on columns of table "user_groups"
"""
input UserGroupsStddevOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type UserGroupsStddevPopFields {
  groupId: Float
  userId: Float
}

"""
order by stddevPop() on columns of table "user_groups"
"""
input UserGroupsStddevPopOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type UserGroupsStddevSampFields {
  groupId: Float
  userId: Float
}

"""
order by stddevSamp() on columns of table "user_groups"
"""
input UserGroupsStddevSampOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
Streaming cursor of the table "user_groups"
"""
input UserGroupsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: UserGroupsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input UserGroupsStreamCursorValueInput {
  groupId: bigint
  userId: bigint
}

"""
aggregate sum on columns
"""
type UserGroupsSumFields {
  groupId: bigint
  userId: bigint
}

"""
order by sum() on columns of table "user_groups"
"""
input UserGroupsSumOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
update columns of table "user_groups"
"""
enum UserGroupsUpdateColumn {
  """
  column name
  """
  groupId

  """
  column name
  """
  userId
}

input UserGroupsUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: UserGroupsIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: UserGroupsSetInput

  """
  filter the rows which have to be updated
  """
  where: UserGroupsBoolExp!
}

"""
aggregate varPop on columns
"""
type UserGroupsVarPopFields {
  groupId: Float
  userId: Float
}

"""
order by varPop() on columns of table "user_groups"
"""
input UserGroupsVarPopOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
aggregate varSamp on columns
"""
type UserGroupsVarSampFields {
  groupId: Float
  userId: Float
}

"""
order by varSamp() on columns of table "user_groups"
"""
input UserGroupsVarSampOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
aggregate variance on columns
"""
type UserGroupsVarianceFields {
  groupId: Float
  userId: Float
}

"""
order by variance() on columns of table "user_groups"
"""
input UserGroupsVarianceOrderBy {
  groupId: OrderBy
  userId: OrderBy
}

"""
columns and relationships of "user_level"
"""
type UserLevel {
  """
  An object relationship
  """
  edition: Edition!
  editionId: bigint!
  label: String!

  """
  An object relationship
  """
  level: Levels!
  levelId: bigint!

  """
  An object relationship
  """
  user: Users!
  userId: bigint!
  userLevelId: bigint!
}

"""
aggregated selection of "user_level"
"""
type UserLevelAggregate {
  aggregate: UserLevelAggregateFields
  nodes: [UserLevel!]!
}

input UserLevelAggregateBoolExp {
  count: userLevelAggregateBoolExpCount
}

"""
aggregate fields of "user_level"
"""
type UserLevelAggregateFields {
  avg: UserLevelAvgFields
  count(columns: [UserLevelSelectColumn!], distinct: Boolean): Int!
  max: UserLevelMaxFields
  min: UserLevelMinFields
  stddev: UserLevelStddevFields
  stddevPop: UserLevelStddevPopFields
  stddevSamp: UserLevelStddevSampFields
  sum: UserLevelSumFields
  varPop: UserLevelVarPopFields
  varSamp: UserLevelVarSampFields
  variance: UserLevelVarianceFields
}

"""
order by aggregate values of table "user_level"
"""
input UserLevelAggregateOrderBy {
  avg: UserLevelAvgOrderBy
  count: OrderBy
  max: UserLevelMaxOrderBy
  min: UserLevelMinOrderBy
  stddev: UserLevelStddevOrderBy
  stddevPop: UserLevelStddevPopOrderBy
  stddevSamp: UserLevelStddevSampOrderBy
  sum: UserLevelSumOrderBy
  varPop: UserLevelVarPopOrderBy
  varSamp: UserLevelVarSampOrderBy
  variance: UserLevelVarianceOrderBy
}

"""
input type for inserting array relation for remote table "user_level"
"""
input UserLevelArrRelInsertInput {
  data: [UserLevelInsertInput!]!

  """
  upsert condition
  """
  onConflict: UserLevelOnConflict
}

"""
aggregate avg on columns
"""
type UserLevelAvgFields {
  editionId: Float
  levelId: Float
  userId: Float
  userLevelId: Float
}

"""
order by avg() on columns of table "user_level"
"""
input UserLevelAvgOrderBy {
  editionId: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
Boolean expression to filter rows from the table "user_level". All fields are combined with a logical 'AND'.
"""
input UserLevelBoolExp {
  _and: [UserLevelBoolExp!]
  _not: UserLevelBoolExp
  _or: [UserLevelBoolExp!]
  edition: EditionBoolExp
  editionId: BigintComparisonExp
  label: StringComparisonExp
  level: LevelsBoolExp
  levelId: BigintComparisonExp
  user: UsersBoolExp
  userId: BigintComparisonExp
  userLevelId: BigintComparisonExp
}

"""
unique or primary key constraints on table "user_level"
"""
enum UserLevelConstraint {
  """
  unique or primary key constraint on columns "user_id", "edition_id"
  """
  unique_user_edition

  """
  unique or primary key constraint on columns "user_id", "level_id"
  """
  user_level_pkey
}

"""
input type for incrementing numeric columns in table "user_level"
"""
input UserLevelIncInput {
  editionId: bigint
  levelId: bigint
  userId: bigint
  userLevelId: bigint
}

"""
input type for inserting data into table "user_level"
"""
input UserLevelInsertInput {
  edition: EditionObjRelInsertInput
  editionId: bigint
  label: String
  level: LevelsObjRelInsertInput
  levelId: bigint
  user: UsersObjRelInsertInput
  userId: bigint
  userLevelId: bigint
}

"""
aggregate max on columns
"""
type UserLevelMaxFields {
  editionId: bigint
  label: String
  levelId: bigint
  userId: bigint
  userLevelId: bigint
}

"""
order by max() on columns of table "user_level"
"""
input UserLevelMaxOrderBy {
  editionId: OrderBy
  label: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
aggregate min on columns
"""
type UserLevelMinFields {
  editionId: bigint
  label: String
  levelId: bigint
  userId: bigint
  userLevelId: bigint
}

"""
order by min() on columns of table "user_level"
"""
input UserLevelMinOrderBy {
  editionId: OrderBy
  label: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
response of any mutation on the table "user_level"
"""
type UserLevelMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [UserLevel!]!
}

"""
on_conflict condition type for table "user_level"
"""
input UserLevelOnConflict {
  constraint: UserLevelConstraint!
  updateColumns: [UserLevelUpdateColumn!]! = []
  where: UserLevelBoolExp
}

"""
Ordering options when selecting data from "user_level".
"""
input UserLevelOrderBy {
  edition: EditionOrderBy
  editionId: OrderBy
  label: OrderBy
  level: LevelsOrderBy
  levelId: OrderBy
  user: UsersOrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
primary key columns input for table: user_level
"""
input UserLevelPkColumnsInput {
  levelId: bigint!
  userId: bigint!
}

"""
select columns of table "user_level"
"""
enum UserLevelSelectColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  label

  """
  column name
  """
  levelId

  """
  column name
  """
  userId

  """
  column name
  """
  userLevelId
}

"""
input type for updating data in table "user_level"
"""
input UserLevelSetInput {
  editionId: bigint
  label: String
  levelId: bigint
  userId: bigint
  userLevelId: bigint
}

"""
aggregate stddev on columns
"""
type UserLevelStddevFields {
  editionId: Float
  levelId: Float
  userId: Float
  userLevelId: Float
}

"""
order by stddev() on columns of table "user_level"
"""
input UserLevelStddevOrderBy {
  editionId: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type UserLevelStddevPopFields {
  editionId: Float
  levelId: Float
  userId: Float
  userLevelId: Float
}

"""
order by stddevPop() on columns of table "user_level"
"""
input UserLevelStddevPopOrderBy {
  editionId: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type UserLevelStddevSampFields {
  editionId: Float
  levelId: Float
  userId: Float
  userLevelId: Float
}

"""
order by stddevSamp() on columns of table "user_level"
"""
input UserLevelStddevSampOrderBy {
  editionId: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
Streaming cursor of the table "user_level"
"""
input UserLevelStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: UserLevelStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input UserLevelStreamCursorValueInput {
  editionId: bigint
  label: String
  levelId: bigint
  userId: bigint
  userLevelId: bigint
}

"""
aggregate sum on columns
"""
type UserLevelSumFields {
  editionId: bigint
  levelId: bigint
  userId: bigint
  userLevelId: bigint
}

"""
order by sum() on columns of table "user_level"
"""
input UserLevelSumOrderBy {
  editionId: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

type UserLevelType {
  edition: EditionType!
  label: String!
  level: LevelType!
  user: UserType!
  userLevelId: ID!
}

"""
update columns of table "user_level"
"""
enum UserLevelUpdateColumn {
  """
  column name
  """
  editionId

  """
  column name
  """
  label

  """
  column name
  """
  levelId

  """
  column name
  """
  userId

  """
  column name
  """
  userLevelId
}

input UserLevelUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: UserLevelIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: UserLevelSetInput

  """
  filter the rows which have to be updated
  """
  where: UserLevelBoolExp!
}

"""
aggregate varPop on columns
"""
type UserLevelVarPopFields {
  editionId: Float
  levelId: Float
  userId: Float
  userLevelId: Float
}

"""
order by varPop() on columns of table "user_level"
"""
input UserLevelVarPopOrderBy {
  editionId: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
aggregate varSamp on columns
"""
type UserLevelVarSampFields {
  editionId: Float
  levelId: Float
  userId: Float
  userLevelId: Float
}

"""
order by varSamp() on columns of table "user_level"
"""
input UserLevelVarSampOrderBy {
  editionId: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

"""
aggregate variance on columns
"""
type UserLevelVarianceFields {
  editionId: Float
  levelId: Float
  userId: Float
  userLevelId: Float
}

"""
order by variance() on columns of table "user_level"
"""
input UserLevelVarianceOrderBy {
  editionId: OrderBy
  levelId: OrderBy
  userId: OrderBy
  userLevelId: OrderBy
}

type UserPointsType {
  categoriesPoints: [CategoryPointsType!]!
  user: UserType!
}

type UserType {
  firstName: String!
  imageFile: FileType
  indexNumber: Int!
  label: String!
  nick: String!
  role: UsersRolesType!
  secondName: String!
  userGroups: [UserGroupType]!
  userId: ID!
  userLevels: [UserLevelType]!
}

"""
columns and relationships of "users"
"""
type Users {
  """
  An array relationship
  """
  chestHistories(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): [ChestHistory!]!

  """
  An aggregate relationship
  """
  chestHistoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): ChestHistoryAggregate!

  """
  An array relationship
  """
  chestHistoriesByTeacherId(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): [ChestHistory!]!

  """
  An aggregate relationship
  """
  chestHistoriesByTeacherIdAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): ChestHistoryAggregate!

  """
  An object relationship
  """
  file: Files
  firstName: String!

  """
  A computed field, executes function "users_fullname"
  """
  fullName: String

  """
  An array relationship
  """
  groups(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): [Groups!]!

  """
  An aggregate relationship
  """
  groupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): GroupsAggregate!
  imageFileId: bigint
  indexNumber: Int!
  label: String!
  nick: String!

  """
  An array relationship
  """
  points(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): [Points!]!

  """
  An aggregate relationship
  """
  pointsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): PointsAggregate!

  """
  An array relationship
  """
  pointsByTeacherId(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): [Points!]!

  """
  An aggregate relationship
  """
  pointsByTeacherIdAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): PointsAggregate!

  """
  An array relationship
  """
  pointsByUpdatedBy(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): [Points!]!

  """
  An aggregate relationship
  """
  pointsByUpdatedByAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): PointsAggregate!

  """
  An array relationship
  """
  pointsHistories(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): [PointsHistory!]!

  """
  An aggregate relationship
  """
  pointsHistoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): PointsHistoryAggregate!

  """
  An array relationship
  """
  pointsHistoriesByTeacherId(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): [PointsHistory!]!

  """
  An aggregate relationship
  """
  pointsHistoriesByTeacherIdAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): PointsHistoryAggregate!
  role: String!
  secondName: String!

  """
  An array relationship
  """
  userGroups(
    """
    distinct select on columns
    """
    distinctOn: [UserGroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserGroupsOrderBy!]

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): [UserGroups!]!

  """
  An aggregate relationship
  """
  userGroupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserGroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserGroupsOrderBy!]

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): UserGroupsAggregate!
  userId: bigint!

  """
  An array relationship
  """
  userLevels(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): [UserLevel!]!

  """
  An aggregate relationship
  """
  userLevelsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): UserLevelAggregate!
}

"""
aggregated selection of "users"
"""
type UsersAggregate {
  aggregate: UsersAggregateFields
  nodes: [Users!]!
}

input UsersAggregateBoolExp {
  count: usersAggregateBoolExpCount
}

"""
aggregate fields of "users"
"""
type UsersAggregateFields {
  avg: UsersAvgFields
  count(columns: [UsersSelectColumn!], distinct: Boolean): Int!
  max: UsersMaxFields
  min: UsersMinFields
  stddev: UsersStddevFields
  stddevPop: UsersStddevPopFields
  stddevSamp: UsersStddevSampFields
  sum: UsersSumFields
  varPop: UsersVarPopFields
  varSamp: UsersVarSampFields
  variance: UsersVarianceFields
}

"""
order by aggregate values of table "users"
"""
input UsersAggregateOrderBy {
  avg: UsersAvgOrderBy
  count: OrderBy
  max: UsersMaxOrderBy
  min: UsersMinOrderBy
  stddev: UsersStddevOrderBy
  stddevPop: UsersStddevPopOrderBy
  stddevSamp: UsersStddevSampOrderBy
  sum: UsersSumOrderBy
  varPop: UsersVarPopOrderBy
  varSamp: UsersVarSampOrderBy
  variance: UsersVarianceOrderBy
}

"""
input type for inserting array relation for remote table "users"
"""
input UsersArrRelInsertInput {
  data: [UsersInsertInput!]!

  """
  upsert condition
  """
  onConflict: UsersOnConflict
}

"""
aggregate avg on columns
"""
type UsersAvgFields {
  imageFileId: Float
  indexNumber: Float
  userId: Float
}

"""
order by avg() on columns of table "users"
"""
input UsersAvgOrderBy {
  imageFileId: OrderBy
  indexNumber: OrderBy
  userId: OrderBy
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input UsersBoolExp {
  _and: [UsersBoolExp!]
  _not: UsersBoolExp
  _or: [UsersBoolExp!]
  chestHistories: ChestHistoryBoolExp
  chestHistoriesAggregate: ChestHistoryAggregateBoolExp
  chestHistoriesByTeacherId: ChestHistoryBoolExp
  chestHistoriesByTeacherIdAggregate: ChestHistoryAggregateBoolExp
  file: FilesBoolExp
  firstName: StringComparisonExp
  fullName: StringComparisonExp
  groups: GroupsBoolExp
  groupsAggregate: GroupsAggregateBoolExp
  imageFileId: BigintComparisonExp
  indexNumber: IntComparisonExp
  label: StringComparisonExp
  nick: StringComparisonExp
  points: PointsBoolExp
  pointsAggregate: PointsAggregateBoolExp
  pointsByTeacherId: PointsBoolExp
  pointsByTeacherIdAggregate: PointsAggregateBoolExp
  pointsByUpdatedBy: PointsBoolExp
  pointsByUpdatedByAggregate: PointsAggregateBoolExp
  pointsHistories: PointsHistoryBoolExp
  pointsHistoriesAggregate: PointsHistoryAggregateBoolExp
  pointsHistoriesByTeacherId: PointsHistoryBoolExp
  pointsHistoriesByTeacherIdAggregate: PointsHistoryAggregateBoolExp
  role: StringComparisonExp
  secondName: StringComparisonExp
  userGroups: UserGroupsBoolExp
  userGroupsAggregate: UserGroupsAggregateBoolExp
  userId: BigintComparisonExp
  userLevels: UserLevelBoolExp
  userLevelsAggregate: UserLevelAggregateBoolExp
}

"""
unique or primary key constraints on table "users"
"""
enum UsersConstraint {
  """
  unique or primary key constraint on columns "index_number"
  """
  uka0sjysw3ars20ri1eg8vilw2r

  """
  unique or primary key constraint on columns "index_number"
  """
  unique_index_number

  """
  unique or primary key constraint on columns "user_id"
  """
  users_pkey
}

"""
input type for incrementing numeric columns in table "users"
"""
input UsersIncInput {
  imageFileId: bigint
  indexNumber: Int
  userId: bigint
}

"""
input type for inserting data into table "users"
"""
input UsersInsertInput {
  chestHistories: ChestHistoryArrRelInsertInput
  chestHistoriesByTeacherId: ChestHistoryArrRelInsertInput
  file: FilesObjRelInsertInput
  firstName: String
  groups: GroupsArrRelInsertInput
  imageFileId: bigint
  indexNumber: Int
  label: String
  nick: String
  points: PointsArrRelInsertInput
  pointsByTeacherId: PointsArrRelInsertInput
  pointsByUpdatedBy: PointsArrRelInsertInput
  pointsHistories: PointsHistoryArrRelInsertInput
  pointsHistoriesByTeacherId: PointsHistoryArrRelInsertInput
  role: String
  secondName: String
  userGroups: UserGroupsArrRelInsertInput
  userId: bigint
  userLevels: UserLevelArrRelInsertInput
}

"""
aggregate max on columns
"""
type UsersMaxFields {
  firstName: String

  """
  A computed field, executes function "users_fullname"
  """
  fullName: String
  imageFileId: bigint
  indexNumber: Int
  label: String
  nick: String
  role: String
  secondName: String
  userId: bigint
}

"""
order by max() on columns of table "users"
"""
input UsersMaxOrderBy {
  firstName: OrderBy
  imageFileId: OrderBy
  indexNumber: OrderBy
  label: OrderBy
  nick: OrderBy
  role: OrderBy
  secondName: OrderBy
  userId: OrderBy
}

"""
aggregate min on columns
"""
type UsersMinFields {
  firstName: String

  """
  A computed field, executes function "users_fullname"
  """
  fullName: String
  imageFileId: bigint
  indexNumber: Int
  label: String
  nick: String
  role: String
  secondName: String
  userId: bigint
}

"""
order by min() on columns of table "users"
"""
input UsersMinOrderBy {
  firstName: OrderBy
  imageFileId: OrderBy
  indexNumber: OrderBy
  label: OrderBy
  nick: OrderBy
  role: OrderBy
  secondName: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "users"
"""
type UsersMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input UsersObjRelInsertInput {
  data: UsersInsertInput!

  """
  upsert condition
  """
  onConflict: UsersOnConflict
}

"""
on_conflict condition type for table "users"
"""
input UsersOnConflict {
  constraint: UsersConstraint!
  updateColumns: [UsersUpdateColumn!]! = []
  where: UsersBoolExp
}

"""
Ordering options when selecting data from "users".
"""
input UsersOrderBy {
  chestHistoriesAggregate: ChestHistoryAggregateOrderBy
  chestHistoriesByTeacherIdAggregate: ChestHistoryAggregateOrderBy
  file: FilesOrderBy
  firstName: OrderBy
  fullName: OrderBy
  groupsAggregate: GroupsAggregateOrderBy
  imageFileId: OrderBy
  indexNumber: OrderBy
  label: OrderBy
  nick: OrderBy
  pointsAggregate: PointsAggregateOrderBy
  pointsByTeacherIdAggregate: PointsAggregateOrderBy
  pointsByUpdatedByAggregate: PointsAggregateOrderBy
  pointsHistoriesAggregate: PointsHistoryAggregateOrderBy
  pointsHistoriesByTeacherIdAggregate: PointsHistoryAggregateOrderBy
  role: OrderBy
  secondName: OrderBy
  userGroupsAggregate: UserGroupsAggregateOrderBy
  userId: OrderBy
  userLevelsAggregate: UserLevelAggregateOrderBy
}

"""
primary key columns input for table: users
"""
input UsersPkColumnsInput {
  userId: bigint!
}

enum UsersRolesType {
  COORDINATOR
  STUDENT
  TEACHER
}

"""
select columns of table "users"
"""
enum UsersSelectColumn {
  """
  column name
  """
  firstName

  """
  column name
  """
  imageFileId

  """
  column name
  """
  indexNumber

  """
  column name
  """
  label

  """
  column name
  """
  nick

  """
  column name
  """
  role

  """
  column name
  """
  secondName

  """
  column name
  """
  userId
}

"""
input type for updating data in table "users"
"""
input UsersSetInput {
  firstName: String
  imageFileId: bigint
  indexNumber: Int
  label: String
  nick: String
  role: String
  secondName: String
  userId: bigint
}

"""
aggregate stddev on columns
"""
type UsersStddevFields {
  imageFileId: Float
  indexNumber: Float
  userId: Float
}

"""
order by stddev() on columns of table "users"
"""
input UsersStddevOrderBy {
  imageFileId: OrderBy
  indexNumber: OrderBy
  userId: OrderBy
}

"""
aggregate stddevPop on columns
"""
type UsersStddevPopFields {
  imageFileId: Float
  indexNumber: Float
  userId: Float
}

"""
order by stddevPop() on columns of table "users"
"""
input UsersStddevPopOrderBy {
  imageFileId: OrderBy
  indexNumber: OrderBy
  userId: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type UsersStddevSampFields {
  imageFileId: Float
  indexNumber: Float
  userId: Float
}

"""
order by stddevSamp() on columns of table "users"
"""
input UsersStddevSampOrderBy {
  imageFileId: OrderBy
  indexNumber: OrderBy
  userId: OrderBy
}

"""
Streaming cursor of the table "users"
"""
input UsersStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: UsersStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input UsersStreamCursorValueInput {
  firstName: String
  imageFileId: bigint
  indexNumber: Int
  label: String
  nick: String
  role: String
  secondName: String
  userId: bigint
}

"""
aggregate sum on columns
"""
type UsersSumFields {
  imageFileId: bigint
  indexNumber: Int
  userId: bigint
}

"""
order by sum() on columns of table "users"
"""
input UsersSumOrderBy {
  imageFileId: OrderBy
  indexNumber: OrderBy
  userId: OrderBy
}

"""
update columns of table "users"
"""
enum UsersUpdateColumn {
  """
  column name
  """
  firstName

  """
  column name
  """
  imageFileId

  """
  column name
  """
  indexNumber

  """
  column name
  """
  label

  """
  column name
  """
  nick

  """
  column name
  """
  role

  """
  column name
  """
  secondName

  """
  column name
  """
  userId
}

input UsersUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: UsersIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: UsersSetInput

  """
  filter the rows which have to be updated
  """
  where: UsersBoolExp!
}

"""
aggregate varPop on columns
"""
type UsersVarPopFields {
  imageFileId: Float
  indexNumber: Float
  userId: Float
}

"""
order by varPop() on columns of table "users"
"""
input UsersVarPopOrderBy {
  imageFileId: OrderBy
  indexNumber: OrderBy
  userId: OrderBy
}

"""
aggregate varSamp on columns
"""
type UsersVarSampFields {
  imageFileId: Float
  indexNumber: Float
  userId: Float
}

"""
order by varSamp() on columns of table "users"
"""
input UsersVarSampOrderBy {
  imageFileId: OrderBy
  indexNumber: OrderBy
  userId: OrderBy
}

"""
aggregate variance on columns
"""
type UsersVarianceFields {
  imageFileId: Float
  indexNumber: Float
  userId: Float
}

"""
order by variance() on columns of table "users"
"""
input UsersVarianceOrderBy {
  imageFileId: OrderBy
  indexNumber: OrderBy
  userId: OrderBy
}

type WeekdayType {
  label: String!
  ordinalNumber: Int!
  weekdayAbbr: String!
  weekdayId: ID!
  weekdayName: String!
}

"""
columns and relationships of "weekdays"
"""
type Weekdays {
  """
  An array relationship
  """
  groups(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): [Groups!]!

  """
  An aggregate relationship
  """
  groupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): GroupsAggregate!
  label: String!
  ordinalNumber: Int!
  weekdayAbbr: String!
  weekdayId: bigint!
  weekdayName: String!
}

"""
aggregated selection of "weekdays"
"""
type WeekdaysAggregate {
  aggregate: WeekdaysAggregateFields
  nodes: [Weekdays!]!
}

"""
aggregate fields of "weekdays"
"""
type WeekdaysAggregateFields {
  avg: WeekdaysAvgFields
  count(columns: [WeekdaysSelectColumn!], distinct: Boolean): Int!
  max: WeekdaysMaxFields
  min: WeekdaysMinFields
  stddev: WeekdaysStddevFields
  stddevPop: WeekdaysStddevPopFields
  stddevSamp: WeekdaysStddevSampFields
  sum: WeekdaysSumFields
  varPop: WeekdaysVarPopFields
  varSamp: WeekdaysVarSampFields
  variance: WeekdaysVarianceFields
}

"""
aggregate avg on columns
"""
type WeekdaysAvgFields {
  ordinalNumber: Float
  weekdayId: Float
}

"""
Boolean expression to filter rows from the table "weekdays". All fields are combined with a logical 'AND'.
"""
input WeekdaysBoolExp {
  _and: [WeekdaysBoolExp!]
  _not: WeekdaysBoolExp
  _or: [WeekdaysBoolExp!]
  groups: GroupsBoolExp
  groupsAggregate: GroupsAggregateBoolExp
  label: StringComparisonExp
  ordinalNumber: IntComparisonExp
  weekdayAbbr: StringComparisonExp
  weekdayId: BigintComparisonExp
  weekdayName: StringComparisonExp
}

"""
unique or primary key constraints on table "weekdays"
"""
enum WeekdaysConstraint {
  """
  unique or primary key constraint on columns "weekday_id"
  """
  weekdays_pkey
}

"""
input type for incrementing numeric columns in table "weekdays"
"""
input WeekdaysIncInput {
  ordinalNumber: Int
  weekdayId: bigint
}

"""
input type for inserting data into table "weekdays"
"""
input WeekdaysInsertInput {
  groups: GroupsArrRelInsertInput
  label: String
  ordinalNumber: Int
  weekdayAbbr: String
  weekdayId: bigint
  weekdayName: String
}

"""
aggregate max on columns
"""
type WeekdaysMaxFields {
  label: String
  ordinalNumber: Int
  weekdayAbbr: String
  weekdayId: bigint
  weekdayName: String
}

"""
aggregate min on columns
"""
type WeekdaysMinFields {
  label: String
  ordinalNumber: Int
  weekdayAbbr: String
  weekdayId: bigint
  weekdayName: String
}

"""
response of any mutation on the table "weekdays"
"""
type WeekdaysMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Weekdays!]!
}

"""
input type for inserting object relation for remote table "weekdays"
"""
input WeekdaysObjRelInsertInput {
  data: WeekdaysInsertInput!

  """
  upsert condition
  """
  onConflict: WeekdaysOnConflict
}

"""
on_conflict condition type for table "weekdays"
"""
input WeekdaysOnConflict {
  constraint: WeekdaysConstraint!
  updateColumns: [WeekdaysUpdateColumn!]! = []
  where: WeekdaysBoolExp
}

"""
Ordering options when selecting data from "weekdays".
"""
input WeekdaysOrderBy {
  groupsAggregate: GroupsAggregateOrderBy
  label: OrderBy
  ordinalNumber: OrderBy
  weekdayAbbr: OrderBy
  weekdayId: OrderBy
  weekdayName: OrderBy
}

"""
primary key columns input for table: weekdays
"""
input WeekdaysPkColumnsInput {
  weekdayId: bigint!
}

"""
select columns of table "weekdays"
"""
enum WeekdaysSelectColumn {
  """
  column name
  """
  label

  """
  column name
  """
  ordinalNumber

  """
  column name
  """
  weekdayAbbr

  """
  column name
  """
  weekdayId

  """
  column name
  """
  weekdayName
}

"""
input type for updating data in table "weekdays"
"""
input WeekdaysSetInput {
  label: String
  ordinalNumber: Int
  weekdayAbbr: String
  weekdayId: bigint
  weekdayName: String
}

"""
aggregate stddev on columns
"""
type WeekdaysStddevFields {
  ordinalNumber: Float
  weekdayId: Float
}

"""
aggregate stddevPop on columns
"""
type WeekdaysStddevPopFields {
  ordinalNumber: Float
  weekdayId: Float
}

"""
aggregate stddevSamp on columns
"""
type WeekdaysStddevSampFields {
  ordinalNumber: Float
  weekdayId: Float
}

"""
Streaming cursor of the table "weekdays"
"""
input WeekdaysStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: WeekdaysStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input WeekdaysStreamCursorValueInput {
  label: String
  ordinalNumber: Int
  weekdayAbbr: String
  weekdayId: bigint
  weekdayName: String
}

"""
aggregate sum on columns
"""
type WeekdaysSumFields {
  ordinalNumber: Int
  weekdayId: bigint
}

"""
update columns of table "weekdays"
"""
enum WeekdaysUpdateColumn {
  """
  column name
  """
  label

  """
  column name
  """
  ordinalNumber

  """
  column name
  """
  weekdayAbbr

  """
  column name
  """
  weekdayId

  """
  column name
  """
  weekdayName
}

input WeekdaysUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: WeekdaysIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: WeekdaysSetInput

  """
  filter the rows which have to be updated
  """
  where: WeekdaysBoolExp!
}

"""
aggregate varPop on columns
"""
type WeekdaysVarPopFields {
  ordinalNumber: Float
  weekdayId: Float
}

"""
aggregate varSamp on columns
"""
type WeekdaysVarSampFields {
  ordinalNumber: Float
  weekdayId: Float
}

"""
aggregate variance on columns
"""
type WeekdaysVarianceFields {
  ordinalNumber: Float
  weekdayId: Float
}

type _Service {
  sdl: String!
}

input awardAggregateBoolExpCount {
  arguments: [AwardSelectColumn!]
  distinct: Boolean
  filter: AwardBoolExp
  predicate: IntComparisonExp!
}

input awardEditionAggregateBoolExpCount {
  arguments: [AwardEditionSelectColumn!]
  distinct: Boolean
  filter: AwardEditionBoolExp
  predicate: IntComparisonExp!
}

scalar bigint

input bonusesAggregateBoolExpCount {
  arguments: [BonusesSelectColumn!]
  distinct: Boolean
  filter: BonusesBoolExp
  predicate: IntComparisonExp!
}

input categoryEditionAggregateBoolExpCount {
  arguments: [CategoryEditionSelectColumn!]
  distinct: Boolean
  filter: CategoryEditionBoolExp
  predicate: IntComparisonExp!
}

input chestAwardAggregateBoolExpCount {
  arguments: [ChestAwardSelectColumn!]
  distinct: Boolean
  filter: ChestAwardBoolExp
  predicate: IntComparisonExp!
}

input chestHistoryAggregateBoolExpBool_and {
  arguments: ChestHistorySelectColumnChestHistoryAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ChestHistoryBoolExp
  predicate: BooleanComparisonExp!
}

input chestHistoryAggregateBoolExpBool_or {
  arguments: ChestHistorySelectColumnChestHistoryAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ChestHistoryBoolExp
  predicate: BooleanComparisonExp!
}

input chestHistoryAggregateBoolExpCount {
  arguments: [ChestHistorySelectColumn!]
  distinct: Boolean
  filter: ChestHistoryBoolExp
  predicate: IntComparisonExp!
}

input chestsAggregateBoolExpCount {
  arguments: [ChestsSelectColumn!]
  distinct: Boolean
  filter: ChestsBoolExp
  predicate: IntComparisonExp!
}

scalar date

input groupsAggregateBoolExpCount {
  arguments: [GroupsSelectColumn!]
  distinct: Boolean
  filter: GroupsBoolExp
  predicate: IntComparisonExp!
}

input levelsAggregateBoolExpBool_and {
  arguments: LevelsSelectColumnLevelsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: LevelsBoolExp
  predicate: BooleanComparisonExp!
}

input levelsAggregateBoolExpBool_or {
  arguments: LevelsSelectColumnLevelsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: LevelsBoolExp
  predicate: BooleanComparisonExp!
}

input levelsAggregateBoolExpCount {
  arguments: [LevelsSelectColumn!]
  distinct: Boolean
  filter: LevelsBoolExp
  predicate: IntComparisonExp!
}

"""
mutation root
"""
type mutation_root {
  addAward(
    awardName: String!
    awardType: String!
    awardValue: Float!
    categoryId: Int!
    label: String = ""
    maxUsages: Int = -1
  ): AwardType
  addAwardToChest(awardId: Int!, chestId: Int!): ChestAwardType
  addAwardToEdition(awardId: Int!, editionId: Int!): AwardEditionType
  addBonusMutation(
    awardId: Int!
    checkDates: Boolean = true
    chestHistoryId: Int!
  ): AddBonusReturnType
  addCategory(
    canAddPoints: Boolean!
    categoryName: String!
    label: String = ""
  ): CategoryType
  addCategoryToEdition(categoryId: Int!, editionId: Int!): CategoryEditionType
  addChest(chestType: String!, editionId: Int!, label: String = ""): ChestType
  addChestToUser(
    chestId: Int!
    subcategoryId: Int!
    teacherId: Int!
    userId: Int!
  ): ChestHistoryType
  addEdition(
    editionName: String!
    editionYear: Int!
    label: String = ""
  ): EditionType
  addGroup(
    editionId: Int!
    endTime: String!
    groupName: String!
    label: String = ""
    startTime: String!
    teacherId: Int!
    weekdayId: Int!
  ): GroupType
  addLevel(
    editionId: Int!
    grade: Float!
    imageFileId: Int
    maximumPoints: Float!
    name: String!
  ): LevelType
  addPointsMutation(
    checkDates: Boolean = true
    studentId: Int!
    subcategoryId: Int!
    teacherId: Int!
    value: Float!
  ): PointType
  addSubcategory(
    categoryId: Int!
    editionId: Int!
    label: String = ""
    maxPoints: Float!
    ordinalNumber: Int!
    subcategoryName: String!
  ): SubcategoryType
  addUser(
    firstName: String!
    indexNumber: Int!
    label: String = ""
    nick: String!
    role: String!
    secondName: String!
  ): UserType
  addUserToGroup(groupId: Int!, userId: Int!): UserGroupType
  assignPhotoToAward(awardId: Int!, fileId: Int): Boolean
  assignPhotoToChest(chestId: Int!, fileId: Int): Boolean
  assignPhotoToLevel(fileId: Int, levelId: Int!): Boolean
  assignPhotoToUser(fileId: Int, userId: Int!): Boolean
  assignPhotosToGroups(editionId: Int!): Boolean

  """
  delete data from the table: "award"
  """
  deleteAward(
    """
    filter the rows which have to be deleted
    """
    where: AwardBoolExp!
  ): AwardMutationResponse

  """
  delete single row from the table: "award"
  """
  deleteAwardByPk(awardId: bigint!): Award

  """
  delete data from the table: "award_edition"
  """
  deleteAwardEdition(
    """
    filter the rows which have to be deleted
    """
    where: AwardEditionBoolExp!
  ): AwardEditionMutationResponse

  """
  delete single row from the table: "award_edition"
  """
  deleteAwardEditionByPk(awardId: bigint!, editionId: bigint!): AwardEdition

  """
  delete data from the table: "bonuses"
  """
  deleteBonuses(
    """
    filter the rows which have to be deleted
    """
    where: BonusesBoolExp!
  ): BonusesMutationResponse

  """
  delete single row from the table: "bonuses"
  """
  deleteBonusesByPk(bonusId: bigint!): Bonuses

  """
  delete data from the table: "categories"
  """
  deleteCategories(
    """
    filter the rows which have to be deleted
    """
    where: CategoriesBoolExp!
  ): CategoriesMutationResponse

  """
  delete single row from the table: "categories"
  """
  deleteCategoriesByPk(categoryId: bigint!): Categories

  """
  delete data from the table: "category_edition"
  """
  deleteCategoryEdition(
    """
    filter the rows which have to be deleted
    """
    where: CategoryEditionBoolExp!
  ): CategoryEditionMutationResponse

  """
  delete single row from the table: "category_edition"
  """
  deleteCategoryEditionByPk(
    categoryId: bigint!
    editionId: bigint!
  ): CategoryEdition

  """
  delete data from the table: "chest_award"
  """
  deleteChestAward(
    """
    filter the rows which have to be deleted
    """
    where: ChestAwardBoolExp!
  ): ChestAwardMutationResponse

  """
  delete single row from the table: "chest_award"
  """
  deleteChestAwardByPk(chestAwardId: bigint!): ChestAward

  """
  delete data from the table: "chest_history"
  """
  deleteChestHistory(
    """
    filter the rows which have to be deleted
    """
    where: ChestHistoryBoolExp!
  ): ChestHistoryMutationResponse

  """
  delete single row from the table: "chest_history"
  """
  deleteChestHistoryByPk(chestHistoryId: bigint!): ChestHistory

  """
  delete data from the table: "chests"
  """
  deleteChests(
    """
    filter the rows which have to be deleted
    """
    where: ChestsBoolExp!
  ): ChestsMutationResponse

  """
  delete single row from the table: "chests"
  """
  deleteChestsByPk(chestId: bigint!): Chests

  """
  delete data from the table: "edition"
  """
  deleteEdition(
    """
    filter the rows which have to be deleted
    """
    where: EditionBoolExp!
  ): EditionMutationResponse

  """
  delete single row from the table: "edition"
  """
  deleteEditionByPk(editionId: bigint!): Edition

  """
  delete data from the table: "files"
  """
  deleteFiles(
    """
    filter the rows which have to be deleted
    """
    where: FilesBoolExp!
  ): FilesMutationResponse

  """
  delete single row from the table: "files"
  """
  deleteFilesByPk(fileId: bigint!): Files

  """
  delete data from the table: "flyway_schema_history"
  """
  deleteFlywaySchemaHistory(
    """
    filter the rows which have to be deleted
    """
    where: FlywaySchemaHistoryBoolExp!
  ): FlywaySchemaHistoryMutationResponse

  """
  delete single row from the table: "flyway_schema_history"
  """
  deleteFlywaySchemaHistoryByPk(installedRank: Int!): FlywaySchemaHistory

  """
  delete data from the table: "groups"
  """
  deleteGroups(
    """
    filter the rows which have to be deleted
    """
    where: GroupsBoolExp!
  ): GroupsMutationResponse

  """
  delete single row from the table: "groups"
  """
  deleteGroupsByPk(groupsId: bigint!): Groups

  """
  delete data from the table: "levels"
  """
  deleteLevels(
    """
    filter the rows which have to be deleted
    """
    where: LevelsBoolExp!
  ): LevelsMutationResponse

  """
  delete single row from the table: "levels"
  """
  deleteLevelsByPk(levelId: bigint!): Levels

  """
  delete data from the table: "points"
  """
  deletePoints(
    """
    filter the rows which have to be deleted
    """
    where: PointsBoolExp!
  ): PointsMutationResponse

  """
  delete single row from the table: "points"
  """
  deletePointsByPk(pointsId: bigint!): Points

  """
  delete data from the table: "points_history"
  """
  deletePointsHistory(
    """
    filter the rows which have to be deleted
    """
    where: PointsHistoryBoolExp!
  ): PointsHistoryMutationResponse

  """
  delete single row from the table: "points_history"
  """
  deletePointsHistoryByPk(pointsHistoryId: bigint!): PointsHistory

  """
  delete data from the table: "subcategories"
  """
  deleteSubcategories(
    """
    filter the rows which have to be deleted
    """
    where: SubcategoriesBoolExp!
  ): SubcategoriesMutationResponse

  """
  delete single row from the table: "subcategories"
  """
  deleteSubcategoriesByPk(subcategoryId: bigint!): Subcategories

  """
  delete data from the table: "user_groups"
  """
  deleteUserGroups(
    """
    filter the rows which have to be deleted
    """
    where: UserGroupsBoolExp!
  ): UserGroupsMutationResponse

  """
  delete single row from the table: "user_groups"
  """
  deleteUserGroupsByPk(groupId: bigint!, userId: bigint!): UserGroups

  """
  delete data from the table: "user_level"
  """
  deleteUserLevel(
    """
    filter the rows which have to be deleted
    """
    where: UserLevelBoolExp!
  ): UserLevelMutationResponse

  """
  delete single row from the table: "user_level"
  """
  deleteUserLevelByPk(levelId: bigint!, userId: bigint!): UserLevel

  """
  delete data from the table: "users"
  """
  deleteUsers(
    """
    filter the rows which have to be deleted
    """
    where: UsersBoolExp!
  ): UsersMutationResponse

  """
  delete single row from the table: "users"
  """
  deleteUsersByPk(userId: bigint!): Users

  """
  delete data from the table: "weekdays"
  """
  deleteWeekdays(
    """
    filter the rows which have to be deleted
    """
    where: WeekdaysBoolExp!
  ): WeekdaysMutationResponse

  """
  delete single row from the table: "weekdays"
  """
  deleteWeekdaysByPk(weekdayId: bigint!): Weekdays
  editAward(
    awardId: Int!
    awardName: String
    awardType: String
    awardValue: Float
    categoryId: Int
    label: String
    maxUsages: Int
  ): AwardType
  editCategory(
    canAddPoints: Boolean
    categoryId: Int!
    categoryName: String
    label: String
  ): CategoryType
  editChest(
    chestId: Int!
    chestType: String
    editionId: Int
    label: String
  ): ChestType
  editChestHistory(
    chestHistoryId: Int!
    chestId: Int
    label: String
    subcategoryId: Int
    teacherId: Int
    userId: Int
  ): ChestHistoryType
  editEdition(
    editionId: Int!
    editionName: String
    editionYear: Int
    label: String
  ): EditionType
  editGroup(
    endTime: String
    groupId: Int!
    groupName: String
    label: String
    startTime: String
    teacherId: Int
    weekdayId: Int
  ): GroupType
  editLevel(
    grade: Float
    imageFileId: Int
    label: String
    levelId: Int!
    maximumPoints: Float
    name: String
  ): LevelType
  editPoints(pointsId: Int!, updatedById: Int!, value: Float): PointType
  editSubcategory(
    label: String
    maxPoints: Float
    ordinalNumber: Int
    subcategoryId: Int!
    subcategoryName: String
  ): SubcategoryType
  editUser(
    firstName: String
    indexNumber: Int
    label: String
    nick: String
    role: String
    secondName: String
    userId: Int!
  ): UserType
  generateSubcategories(
    categoryId: Int!
    editionId: Int!
    maxPoints: Float!
    subcategoryCount: Int!
    subcategoryPrefix: String!
  ): [SubcategoryType]

  """
  insert data into the table: "award"
  """
  insertAward(
    """
    the rows to be inserted
    """
    objects: [AwardInsertInput!]!

    """
    upsert condition
    """
    onConflict: AwardOnConflict
  ): AwardMutationResponse

  """
  insert data into the table: "award_edition"
  """
  insertAwardEdition(
    """
    the rows to be inserted
    """
    objects: [AwardEditionInsertInput!]!

    """
    upsert condition
    """
    onConflict: AwardEditionOnConflict
  ): AwardEditionMutationResponse

  """
  insert a single row into the table: "award_edition"
  """
  insertAwardEditionOne(
    """
    the row to be inserted
    """
    object: AwardEditionInsertInput!

    """
    upsert condition
    """
    onConflict: AwardEditionOnConflict
  ): AwardEdition

  """
  insert a single row into the table: "award"
  """
  insertAwardOne(
    """
    the row to be inserted
    """
    object: AwardInsertInput!

    """
    upsert condition
    """
    onConflict: AwardOnConflict
  ): Award

  """
  insert data into the table: "bonuses"
  """
  insertBonuses(
    """
    the rows to be inserted
    """
    objects: [BonusesInsertInput!]!

    """
    upsert condition
    """
    onConflict: BonusesOnConflict
  ): BonusesMutationResponse

  """
  insert a single row into the table: "bonuses"
  """
  insertBonusesOne(
    """
    the row to be inserted
    """
    object: BonusesInsertInput!

    """
    upsert condition
    """
    onConflict: BonusesOnConflict
  ): Bonuses

  """
  insert data into the table: "categories"
  """
  insertCategories(
    """
    the rows to be inserted
    """
    objects: [CategoriesInsertInput!]!

    """
    upsert condition
    """
    onConflict: CategoriesOnConflict
  ): CategoriesMutationResponse

  """
  insert a single row into the table: "categories"
  """
  insertCategoriesOne(
    """
    the row to be inserted
    """
    object: CategoriesInsertInput!

    """
    upsert condition
    """
    onConflict: CategoriesOnConflict
  ): Categories

  """
  insert data into the table: "category_edition"
  """
  insertCategoryEdition(
    """
    the rows to be inserted
    """
    objects: [CategoryEditionInsertInput!]!

    """
    upsert condition
    """
    onConflict: CategoryEditionOnConflict
  ): CategoryEditionMutationResponse

  """
  insert a single row into the table: "category_edition"
  """
  insertCategoryEditionOne(
    """
    the row to be inserted
    """
    object: CategoryEditionInsertInput!

    """
    upsert condition
    """
    onConflict: CategoryEditionOnConflict
  ): CategoryEdition

  """
  insert data into the table: "chest_award"
  """
  insertChestAward(
    """
    the rows to be inserted
    """
    objects: [ChestAwardInsertInput!]!

    """
    upsert condition
    """
    onConflict: ChestAwardOnConflict
  ): ChestAwardMutationResponse

  """
  insert a single row into the table: "chest_award"
  """
  insertChestAwardOne(
    """
    the row to be inserted
    """
    object: ChestAwardInsertInput!

    """
    upsert condition
    """
    onConflict: ChestAwardOnConflict
  ): ChestAward

  """
  insert data into the table: "chest_history"
  """
  insertChestHistory(
    """
    the rows to be inserted
    """
    objects: [ChestHistoryInsertInput!]!

    """
    upsert condition
    """
    onConflict: ChestHistoryOnConflict
  ): ChestHistoryMutationResponse

  """
  insert a single row into the table: "chest_history"
  """
  insertChestHistoryOne(
    """
    the row to be inserted
    """
    object: ChestHistoryInsertInput!

    """
    upsert condition
    """
    onConflict: ChestHistoryOnConflict
  ): ChestHistory

  """
  insert data into the table: "chests"
  """
  insertChests(
    """
    the rows to be inserted
    """
    objects: [ChestsInsertInput!]!

    """
    upsert condition
    """
    onConflict: ChestsOnConflict
  ): ChestsMutationResponse

  """
  insert a single row into the table: "chests"
  """
  insertChestsOne(
    """
    the row to be inserted
    """
    object: ChestsInsertInput!

    """
    upsert condition
    """
    onConflict: ChestsOnConflict
  ): Chests

  """
  insert data into the table: "edition"
  """
  insertEdition(
    """
    the rows to be inserted
    """
    objects: [EditionInsertInput!]!

    """
    upsert condition
    """
    onConflict: EditionOnConflict
  ): EditionMutationResponse

  """
  insert a single row into the table: "edition"
  """
  insertEditionOne(
    """
    the row to be inserted
    """
    object: EditionInsertInput!

    """
    upsert condition
    """
    onConflict: EditionOnConflict
  ): Edition

  """
  insert data into the table: "files"
  """
  insertFiles(
    """
    the rows to be inserted
    """
    objects: [FilesInsertInput!]!

    """
    upsert condition
    """
    onConflict: FilesOnConflict
  ): FilesMutationResponse

  """
  insert a single row into the table: "files"
  """
  insertFilesOne(
    """
    the row to be inserted
    """
    object: FilesInsertInput!

    """
    upsert condition
    """
    onConflict: FilesOnConflict
  ): Files

  """
  insert data into the table: "flyway_schema_history"
  """
  insertFlywaySchemaHistory(
    """
    the rows to be inserted
    """
    objects: [FlywaySchemaHistoryInsertInput!]!

    """
    upsert condition
    """
    onConflict: FlywaySchemaHistoryOnConflict
  ): FlywaySchemaHistoryMutationResponse

  """
  insert a single row into the table: "flyway_schema_history"
  """
  insertFlywaySchemaHistoryOne(
    """
    the row to be inserted
    """
    object: FlywaySchemaHistoryInsertInput!

    """
    upsert condition
    """
    onConflict: FlywaySchemaHistoryOnConflict
  ): FlywaySchemaHistory

  """
  insert data into the table: "groups"
  """
  insertGroups(
    """
    the rows to be inserted
    """
    objects: [GroupsInsertInput!]!

    """
    upsert condition
    """
    onConflict: GroupsOnConflict
  ): GroupsMutationResponse

  """
  insert a single row into the table: "groups"
  """
  insertGroupsOne(
    """
    the row to be inserted
    """
    object: GroupsInsertInput!

    """
    upsert condition
    """
    onConflict: GroupsOnConflict
  ): Groups

  """
  insert data into the table: "levels"
  """
  insertLevels(
    """
    the rows to be inserted
    """
    objects: [LevelsInsertInput!]!

    """
    upsert condition
    """
    onConflict: LevelsOnConflict
  ): LevelsMutationResponse

  """
  insert a single row into the table: "levels"
  """
  insertLevelsOne(
    """
    the row to be inserted
    """
    object: LevelsInsertInput!

    """
    upsert condition
    """
    onConflict: LevelsOnConflict
  ): Levels

  """
  insert data into the table: "points"
  """
  insertPoints(
    """
    the rows to be inserted
    """
    objects: [PointsInsertInput!]!

    """
    upsert condition
    """
    onConflict: PointsOnConflict
  ): PointsMutationResponse

  """
  insert data into the table: "points_history"
  """
  insertPointsHistory(
    """
    the rows to be inserted
    """
    objects: [PointsHistoryInsertInput!]!

    """
    upsert condition
    """
    onConflict: PointsHistoryOnConflict
  ): PointsHistoryMutationResponse

  """
  insert a single row into the table: "points_history"
  """
  insertPointsHistoryOne(
    """
    the row to be inserted
    """
    object: PointsHistoryInsertInput!

    """
    upsert condition
    """
    onConflict: PointsHistoryOnConflict
  ): PointsHistory

  """
  insert a single row into the table: "points"
  """
  insertPointsOne(
    """
    the row to be inserted
    """
    object: PointsInsertInput!

    """
    upsert condition
    """
    onConflict: PointsOnConflict
  ): Points

  """
  insert data into the table: "subcategories"
  """
  insertSubcategories(
    """
    the rows to be inserted
    """
    objects: [SubcategoriesInsertInput!]!

    """
    upsert condition
    """
    onConflict: SubcategoriesOnConflict
  ): SubcategoriesMutationResponse

  """
  insert a single row into the table: "subcategories"
  """
  insertSubcategoriesOne(
    """
    the row to be inserted
    """
    object: SubcategoriesInsertInput!

    """
    upsert condition
    """
    onConflict: SubcategoriesOnConflict
  ): Subcategories

  """
  insert data into the table: "user_groups"
  """
  insertUserGroups(
    """
    the rows to be inserted
    """
    objects: [UserGroupsInsertInput!]!

    """
    upsert condition
    """
    onConflict: UserGroupsOnConflict
  ): UserGroupsMutationResponse

  """
  insert a single row into the table: "user_groups"
  """
  insertUserGroupsOne(
    """
    the row to be inserted
    """
    object: UserGroupsInsertInput!

    """
    upsert condition
    """
    onConflict: UserGroupsOnConflict
  ): UserGroups

  """
  insert data into the table: "user_level"
  """
  insertUserLevel(
    """
    the rows to be inserted
    """
    objects: [UserLevelInsertInput!]!

    """
    upsert condition
    """
    onConflict: UserLevelOnConflict
  ): UserLevelMutationResponse

  """
  insert a single row into the table: "user_level"
  """
  insertUserLevelOne(
    """
    the row to be inserted
    """
    object: UserLevelInsertInput!

    """
    upsert condition
    """
    onConflict: UserLevelOnConflict
  ): UserLevel

  """
  insert data into the table: "users"
  """
  insertUsers(
    """
    the rows to be inserted
    """
    objects: [UsersInsertInput!]!

    """
    upsert condition
    """
    onConflict: UsersOnConflict
  ): UsersMutationResponse

  """
  insert a single row into the table: "users"
  """
  insertUsersOne(
    """
    the row to be inserted
    """
    object: UsersInsertInput!

    """
    upsert condition
    """
    onConflict: UsersOnConflict
  ): Users

  """
  insert data into the table: "weekdays"
  """
  insertWeekdays(
    """
    the rows to be inserted
    """
    objects: [WeekdaysInsertInput!]!

    """
    upsert condition
    """
    onConflict: WeekdaysOnConflict
  ): WeekdaysMutationResponse

  """
  insert a single row into the table: "weekdays"
  """
  insertWeekdaysOne(
    """
    the row to be inserted
    """
    object: WeekdaysInsertInput!

    """
    upsert condition
    """
    onConflict: WeekdaysOnConflict
  ): Weekdays
  removeAwardFromChest(awardId: Int!, chestId: Int!): Boolean
  removeAwardFromEdition(awardId: Int!, editionId: Int!): Boolean
  removeCategory(categoryId: Int!): Boolean
  removeCategoryFromEdition(categoryId: Int!, editionId: Int!): Boolean
  removeChest(chestId: Int!): Boolean
  removeChestFromUser(chestHistoryId: Int!): Boolean
  removeEdition(editionId: Int!): Boolean
  removeGroup(groupId: Int!): Boolean
  removeLevel(levelId: Int!): Boolean
  removePoints(pointsId: Int!): Boolean
  removeSubcategory(subcategoryId: Int!): Boolean
  removeUser(userId: Int!): Boolean
  removeUserFromGroup(groupId: Int!, userId: Int!): Boolean

  """
  update data of the table: "award"
  """
  updateAward(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AwardIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AwardSetInput

    """
    filter the rows which have to be updated
    """
    where: AwardBoolExp!
  ): AwardMutationResponse

  """
  update single row of the table: "award"
  """
  updateAwardByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AwardIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AwardSetInput
    pkColumns: AwardPkColumnsInput!
  ): Award

  """
  update data of the table: "award_edition"
  """
  updateAwardEdition(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AwardEditionIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AwardEditionSetInput

    """
    filter the rows which have to be updated
    """
    where: AwardEditionBoolExp!
  ): AwardEditionMutationResponse

  """
  update single row of the table: "award_edition"
  """
  updateAwardEditionByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AwardEditionIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AwardEditionSetInput
    pkColumns: AwardEditionPkColumnsInput!
  ): AwardEdition

  """
  update multiples rows of table: "award_edition"
  """
  updateAwardEditionMany(
    """
    updates to execute, in order
    """
    updates: [AwardEditionUpdates!]!
  ): [AwardEditionMutationResponse]

  """
  update multiples rows of table: "award"
  """
  updateAwardMany(
    """
    updates to execute, in order
    """
    updates: [AwardUpdates!]!
  ): [AwardMutationResponse]

  """
  update data of the table: "bonuses"
  """
  updateBonuses(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: BonusesIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: BonusesSetInput

    """
    filter the rows which have to be updated
    """
    where: BonusesBoolExp!
  ): BonusesMutationResponse

  """
  update single row of the table: "bonuses"
  """
  updateBonusesByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: BonusesIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: BonusesSetInput
    pkColumns: BonusesPkColumnsInput!
  ): Bonuses

  """
  update multiples rows of table: "bonuses"
  """
  updateBonusesMany(
    """
    updates to execute, in order
    """
    updates: [BonusesUpdates!]!
  ): [BonusesMutationResponse]

  """
  update data of the table: "categories"
  """
  updateCategories(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: CategoriesIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: CategoriesSetInput

    """
    filter the rows which have to be updated
    """
    where: CategoriesBoolExp!
  ): CategoriesMutationResponse

  """
  update single row of the table: "categories"
  """
  updateCategoriesByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: CategoriesIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: CategoriesSetInput
    pkColumns: CategoriesPkColumnsInput!
  ): Categories

  """
  update multiples rows of table: "categories"
  """
  updateCategoriesMany(
    """
    updates to execute, in order
    """
    updates: [CategoriesUpdates!]!
  ): [CategoriesMutationResponse]

  """
  update data of the table: "category_edition"
  """
  updateCategoryEdition(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: CategoryEditionIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: CategoryEditionSetInput

    """
    filter the rows which have to be updated
    """
    where: CategoryEditionBoolExp!
  ): CategoryEditionMutationResponse

  """
  update single row of the table: "category_edition"
  """
  updateCategoryEditionByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: CategoryEditionIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: CategoryEditionSetInput
    pkColumns: CategoryEditionPkColumnsInput!
  ): CategoryEdition

  """
  update multiples rows of table: "category_edition"
  """
  updateCategoryEditionMany(
    """
    updates to execute, in order
    """
    updates: [CategoryEditionUpdates!]!
  ): [CategoryEditionMutationResponse]

  """
  update data of the table: "chest_award"
  """
  updateChestAward(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ChestAwardIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ChestAwardSetInput

    """
    filter the rows which have to be updated
    """
    where: ChestAwardBoolExp!
  ): ChestAwardMutationResponse

  """
  update single row of the table: "chest_award"
  """
  updateChestAwardByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ChestAwardIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ChestAwardSetInput
    pkColumns: ChestAwardPkColumnsInput!
  ): ChestAward

  """
  update multiples rows of table: "chest_award"
  """
  updateChestAwardMany(
    """
    updates to execute, in order
    """
    updates: [ChestAwardUpdates!]!
  ): [ChestAwardMutationResponse]

  """
  update data of the table: "chest_history"
  """
  updateChestHistory(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ChestHistoryIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ChestHistorySetInput

    """
    filter the rows which have to be updated
    """
    where: ChestHistoryBoolExp!
  ): ChestHistoryMutationResponse

  """
  update single row of the table: "chest_history"
  """
  updateChestHistoryByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ChestHistoryIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ChestHistorySetInput
    pkColumns: ChestHistoryPkColumnsInput!
  ): ChestHistory

  """
  update multiples rows of table: "chest_history"
  """
  updateChestHistoryMany(
    """
    updates to execute, in order
    """
    updates: [ChestHistoryUpdates!]!
  ): [ChestHistoryMutationResponse]

  """
  update data of the table: "chests"
  """
  updateChests(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ChestsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ChestsSetInput

    """
    filter the rows which have to be updated
    """
    where: ChestsBoolExp!
  ): ChestsMutationResponse

  """
  update single row of the table: "chests"
  """
  updateChestsByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ChestsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ChestsSetInput
    pkColumns: ChestsPkColumnsInput!
  ): Chests

  """
  update multiples rows of table: "chests"
  """
  updateChestsMany(
    """
    updates to execute, in order
    """
    updates: [ChestsUpdates!]!
  ): [ChestsMutationResponse]

  """
  update data of the table: "edition"
  """
  updateEdition(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: EditionIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: EditionSetInput

    """
    filter the rows which have to be updated
    """
    where: EditionBoolExp!
  ): EditionMutationResponse

  """
  update single row of the table: "edition"
  """
  updateEditionByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: EditionIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: EditionSetInput
    pkColumns: EditionPkColumnsInput!
  ): Edition

  """
  update multiples rows of table: "edition"
  """
  updateEditionMany(
    """
    updates to execute, in order
    """
    updates: [EditionUpdates!]!
  ): [EditionMutationResponse]

  """
  update data of the table: "files"
  """
  updateFiles(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: FilesIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: FilesSetInput

    """
    filter the rows which have to be updated
    """
    where: FilesBoolExp!
  ): FilesMutationResponse

  """
  update single row of the table: "files"
  """
  updateFilesByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: FilesIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: FilesSetInput
    pkColumns: FilesPkColumnsInput!
  ): Files

  """
  update multiples rows of table: "files"
  """
  updateFilesMany(
    """
    updates to execute, in order
    """
    updates: [FilesUpdates!]!
  ): [FilesMutationResponse]

  """
  update data of the table: "flyway_schema_history"
  """
  updateFlywaySchemaHistory(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: FlywaySchemaHistoryIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: FlywaySchemaHistorySetInput

    """
    filter the rows which have to be updated
    """
    where: FlywaySchemaHistoryBoolExp!
  ): FlywaySchemaHistoryMutationResponse

  """
  update single row of the table: "flyway_schema_history"
  """
  updateFlywaySchemaHistoryByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: FlywaySchemaHistoryIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: FlywaySchemaHistorySetInput
    pkColumns: FlywaySchemaHistoryPkColumnsInput!
  ): FlywaySchemaHistory

  """
  update multiples rows of table: "flyway_schema_history"
  """
  updateFlywaySchemaHistoryMany(
    """
    updates to execute, in order
    """
    updates: [FlywaySchemaHistoryUpdates!]!
  ): [FlywaySchemaHistoryMutationResponse]

  """
  update data of the table: "groups"
  """
  updateGroups(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: GroupsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: GroupsSetInput

    """
    filter the rows which have to be updated
    """
    where: GroupsBoolExp!
  ): GroupsMutationResponse

  """
  update single row of the table: "groups"
  """
  updateGroupsByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: GroupsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: GroupsSetInput
    pkColumns: GroupsPkColumnsInput!
  ): Groups

  """
  update multiples rows of table: "groups"
  """
  updateGroupsMany(
    """
    updates to execute, in order
    """
    updates: [GroupsUpdates!]!
  ): [GroupsMutationResponse]

  """
  update data of the table: "levels"
  """
  updateLevels(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LevelsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LevelsSetInput

    """
    filter the rows which have to be updated
    """
    where: LevelsBoolExp!
  ): LevelsMutationResponse

  """
  update single row of the table: "levels"
  """
  updateLevelsByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LevelsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LevelsSetInput
    pkColumns: LevelsPkColumnsInput!
  ): Levels

  """
  update multiples rows of table: "levels"
  """
  updateLevelsMany(
    """
    updates to execute, in order
    """
    updates: [LevelsUpdates!]!
  ): [LevelsMutationResponse]

  """
  update data of the table: "points"
  """
  updatePoints(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: PointsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: PointsSetInput

    """
    filter the rows which have to be updated
    """
    where: PointsBoolExp!
  ): PointsMutationResponse

  """
  update single row of the table: "points"
  """
  updatePointsByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: PointsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: PointsSetInput
    pkColumns: PointsPkColumnsInput!
  ): Points

  """
  update data of the table: "points_history"
  """
  updatePointsHistory(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: PointsHistoryIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: PointsHistorySetInput

    """
    filter the rows which have to be updated
    """
    where: PointsHistoryBoolExp!
  ): PointsHistoryMutationResponse

  """
  update single row of the table: "points_history"
  """
  updatePointsHistoryByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: PointsHistoryIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: PointsHistorySetInput
    pkColumns: PointsHistoryPkColumnsInput!
  ): PointsHistory

  """
  update multiples rows of table: "points_history"
  """
  updatePointsHistoryMany(
    """
    updates to execute, in order
    """
    updates: [PointsHistoryUpdates!]!
  ): [PointsHistoryMutationResponse]

  """
  update multiples rows of table: "points"
  """
  updatePointsMany(
    """
    updates to execute, in order
    """
    updates: [PointsUpdates!]!
  ): [PointsMutationResponse]

  """
  update data of the table: "subcategories"
  """
  updateSubcategories(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: SubcategoriesIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: SubcategoriesSetInput

    """
    filter the rows which have to be updated
    """
    where: SubcategoriesBoolExp!
  ): SubcategoriesMutationResponse

  """
  update single row of the table: "subcategories"
  """
  updateSubcategoriesByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: SubcategoriesIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: SubcategoriesSetInput
    pkColumns: SubcategoriesPkColumnsInput!
  ): Subcategories

  """
  update multiples rows of table: "subcategories"
  """
  updateSubcategoriesMany(
    """
    updates to execute, in order
    """
    updates: [SubcategoriesUpdates!]!
  ): [SubcategoriesMutationResponse]

  """
  update data of the table: "user_groups"
  """
  updateUserGroups(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: UserGroupsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: UserGroupsSetInput

    """
    filter the rows which have to be updated
    """
    where: UserGroupsBoolExp!
  ): UserGroupsMutationResponse

  """
  update single row of the table: "user_groups"
  """
  updateUserGroupsByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: UserGroupsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: UserGroupsSetInput
    pkColumns: UserGroupsPkColumnsInput!
  ): UserGroups

  """
  update multiples rows of table: "user_groups"
  """
  updateUserGroupsMany(
    """
    updates to execute, in order
    """
    updates: [UserGroupsUpdates!]!
  ): [UserGroupsMutationResponse]

  """
  update data of the table: "user_level"
  """
  updateUserLevel(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: UserLevelIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: UserLevelSetInput

    """
    filter the rows which have to be updated
    """
    where: UserLevelBoolExp!
  ): UserLevelMutationResponse

  """
  update single row of the table: "user_level"
  """
  updateUserLevelByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: UserLevelIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: UserLevelSetInput
    pkColumns: UserLevelPkColumnsInput!
  ): UserLevel

  """
  update multiples rows of table: "user_level"
  """
  updateUserLevelMany(
    """
    updates to execute, in order
    """
    updates: [UserLevelUpdates!]!
  ): [UserLevelMutationResponse]

  """
  update data of the table: "users"
  """
  updateUsers(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: UsersIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: UsersSetInput

    """
    filter the rows which have to be updated
    """
    where: UsersBoolExp!
  ): UsersMutationResponse

  """
  update single row of the table: "users"
  """
  updateUsersByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: UsersIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: UsersSetInput
    pkColumns: UsersPkColumnsInput!
  ): Users

  """
  update multiples rows of table: "users"
  """
  updateUsersMany(
    """
    updates to execute, in order
    """
    updates: [UsersUpdates!]!
  ): [UsersMutationResponse]

  """
  update data of the table: "weekdays"
  """
  updateWeekdays(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: WeekdaysIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: WeekdaysSetInput

    """
    filter the rows which have to be updated
    """
    where: WeekdaysBoolExp!
  ): WeekdaysMutationResponse

  """
  update single row of the table: "weekdays"
  """
  updateWeekdaysByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: WeekdaysIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: WeekdaysSetInput
    pkColumns: WeekdaysPkColumnsInput!
  ): Weekdays

  """
  update multiples rows of table: "weekdays"
  """
  updateWeekdaysMany(
    """
    updates to execute, in order
    """
    updates: [WeekdaysUpdates!]!
  ): [WeekdaysMutationResponse]
}

scalar numeric

input pointsAggregateBoolExpCount {
  arguments: [PointsSelectColumn!]
  distinct: Boolean
  filter: PointsBoolExp
  predicate: IntComparisonExp!
}

input pointsHistoryAggregateBoolExpCount {
  arguments: [PointsHistorySelectColumn!]
  distinct: Boolean
  filter: PointsHistoryBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  _service: _Service!

  """
  fetch data from the table: "award"
  """
  award(
    """
    distinct select on columns
    """
    distinctOn: [AwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardOrderBy!]

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): [Award!]!

  """
  fetch aggregated fields from the table: "award"
  """
  awardAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardOrderBy!]

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): AwardAggregate!

  """
  fetch data from the table: "award" using primary key columns
  """
  awardByPk(awardId: bigint!): Award

  """
  fetch data from the table: "award_edition"
  """
  awardEdition(
    """
    distinct select on columns
    """
    distinctOn: [AwardEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardEditionOrderBy!]

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): [AwardEdition!]!

  """
  fetch aggregated fields from the table: "award_edition"
  """
  awardEditionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AwardEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardEditionOrderBy!]

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): AwardEditionAggregate!

  """
  fetch data from the table: "award_edition" using primary key columns
  """
  awardEditionByPk(awardId: bigint!, editionId: bigint!): AwardEdition

  """
  An array relationship
  """
  bonuses(
    """
    distinct select on columns
    """
    distinctOn: [BonusesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BonusesOrderBy!]

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): [Bonuses!]!

  """
  An aggregate relationship
  """
  bonusesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [BonusesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BonusesOrderBy!]

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): BonusesAggregate!

  """
  fetch data from the table: "bonuses" using primary key columns
  """
  bonusesByPk(bonusId: bigint!): Bonuses

  """
  fetch data from the table: "categories"
  """
  categories(
    """
    distinct select on columns
    """
    distinctOn: [CategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: CategoriesBoolExp
  ): [Categories!]!

  """
  fetch aggregated fields from the table: "categories"
  """
  categoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [CategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: CategoriesBoolExp
  ): CategoriesAggregate!

  """
  fetch data from the table: "categories" using primary key columns
  """
  categoriesByPk(categoryId: bigint!): Categories

  """
  fetch data from the table: "category_edition"
  """
  categoryEdition(
    """
    distinct select on columns
    """
    distinctOn: [CategoryEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoryEditionOrderBy!]

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): [CategoryEdition!]!

  """
  fetch aggregated fields from the table: "category_edition"
  """
  categoryEditionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [CategoryEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoryEditionOrderBy!]

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): CategoryEditionAggregate!

  """
  fetch data from the table: "category_edition" using primary key columns
  """
  categoryEditionByPk(categoryId: bigint!, editionId: bigint!): CategoryEdition

  """
  fetch data from the table: "chest_award"
  """
  chestAward(
    """
    distinct select on columns
    """
    distinctOn: [ChestAwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestAwardOrderBy!]

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): [ChestAward!]!

  """
  fetch aggregated fields from the table: "chest_award"
  """
  chestAwardAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestAwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestAwardOrderBy!]

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): ChestAwardAggregate!

  """
  fetch data from the table: "chest_award" using primary key columns
  """
  chestAwardByPk(chestAwardId: bigint!): ChestAward

  """
  fetch data from the table: "chest_history"
  """
  chestHistory(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): [ChestHistory!]!

  """
  fetch aggregated fields from the table: "chest_history"
  """
  chestHistoryAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): ChestHistoryAggregate!

  """
  fetch data from the table: "chest_history" using primary key columns
  """
  chestHistoryByPk(chestHistoryId: bigint!): ChestHistory

  """
  An array relationship
  """
  chests(
    """
    distinct select on columns
    """
    distinctOn: [ChestsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestsOrderBy!]

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): [Chests!]!

  """
  An aggregate relationship
  """
  chestsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestsOrderBy!]

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): ChestsAggregate!

  """
  fetch data from the table: "chests" using primary key columns
  """
  chestsByPk(chestId: bigint!): Chests

  """
  fetch data from the table: "edition"
  """
  edition(
    """
    distinct select on columns
    """
    distinctOn: [EditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [EditionOrderBy!]

    """
    filter the rows returned
    """
    where: EditionBoolExp
  ): [Edition!]!

  """
  fetch aggregated fields from the table: "edition"
  """
  editionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [EditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [EditionOrderBy!]

    """
    filter the rows returned
    """
    where: EditionBoolExp
  ): EditionAggregate!

  """
  fetch data from the table: "edition" using primary key columns
  """
  editionByPk(editionId: bigint!): Edition

  """
  fetch data from the table: "files"
  """
  files(
    """
    distinct select on columns
    """
    distinctOn: [FilesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [FilesOrderBy!]

    """
    filter the rows returned
    """
    where: FilesBoolExp
  ): [Files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  filesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [FilesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [FilesOrderBy!]

    """
    filter the rows returned
    """
    where: FilesBoolExp
  ): FilesAggregate!

  """
  fetch data from the table: "files" using primary key columns
  """
  filesByPk(fileId: bigint!): Files

  """
  fetch data from the table: "flyway_schema_history"
  """
  flywaySchemaHistory(
    """
    distinct select on columns
    """
    distinctOn: [FlywaySchemaHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [FlywaySchemaHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: FlywaySchemaHistoryBoolExp
  ): [FlywaySchemaHistory!]!

  """
  fetch aggregated fields from the table: "flyway_schema_history"
  """
  flywaySchemaHistoryAggregate(
    """
    distinct select on columns
    """
    distinctOn: [FlywaySchemaHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [FlywaySchemaHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: FlywaySchemaHistoryBoolExp
  ): FlywaySchemaHistoryAggregate!

  """
  fetch data from the table: "flyway_schema_history" using primary key columns
  """
  flywaySchemaHistoryByPk(installedRank: Int!): FlywaySchemaHistory
  getGroupsInEdition(editionId: Int!, teacherId: Int!): [GroupTeacherType!]!
  getNeighboringLevels(editionId: Int!, studentId: Int!): NeighboringLevelsType!
  getPossibleGroupDates(editionId: Int!): [GroupDateType!]!
  getPossibleGroupsTimeSpans(editionId: Int!): [TimeSpansType!]!
  getPossibleGroupsWeekdays(editionId: Int!): [WeekdayType!]!
  getStudentPoints(editionId: Int!, studentId: Int!): StudentPointsType!
  getSumOfPointsForStudentByCategory(
    editionId: Int!
    studentId: Int!
  ): [CategoryPointsSumType!]!
  getUsersInGroupWithPoints(groupId: Int!): [UserPointsType]!

  """
  An array relationship
  """
  groups(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): [Groups!]!

  """
  An aggregate relationship
  """
  groupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): GroupsAggregate!

  """
  fetch data from the table: "groups" using primary key columns
  """
  groupsByPk(groupsId: bigint!): Groups

  """
  fetch data from the table: "hall_of_fame"
  """
  hallOfFame(
    """
    distinct select on columns
    """
    distinctOn: [HallOfFameSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [HallOfFameOrderBy!]

    """
    filter the rows returned
    """
    where: HallOfFameBoolExp
  ): [HallOfFame!]!

  """
  fetch aggregated fields from the table: "hall_of_fame"
  """
  hallOfFameAggregate(
    """
    distinct select on columns
    """
    distinctOn: [HallOfFameSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [HallOfFameOrderBy!]

    """
    filter the rows returned
    """
    where: HallOfFameBoolExp
  ): HallOfFameAggregate!

  """
  An array relationship
  """
  levels(
    """
    distinct select on columns
    """
    distinctOn: [LevelsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LevelsOrderBy!]

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): [Levels!]!

  """
  An aggregate relationship
  """
  levelsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LevelsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LevelsOrderBy!]

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): LevelsAggregate!

  """
  fetch data from the table: "levels" using primary key columns
  """
  levelsByPk(levelId: bigint!): Levels

  """
  An array relationship
  """
  points(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): [Points!]!

  """
  An aggregate relationship
  """
  pointsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): PointsAggregate!

  """
  fetch data from the table: "points" using primary key columns
  """
  pointsByPk(pointsId: bigint!): Points

  """
  fetch data from the table: "points_history"
  """
  pointsHistory(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): [PointsHistory!]!

  """
  fetch aggregated fields from the table: "points_history"
  """
  pointsHistoryAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): PointsHistoryAggregate!

  """
  fetch data from the table: "points_history" using primary key columns
  """
  pointsHistoryByPk(pointsHistoryId: bigint!): PointsHistory

  """
  An array relationship
  """
  subcategories(
    """
    distinct select on columns
    """
    distinctOn: [SubcategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SubcategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): [Subcategories!]!

  """
  An aggregate relationship
  """
  subcategoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SubcategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SubcategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): SubcategoriesAggregate!

  """
  fetch data from the table: "subcategories" using primary key columns
  """
  subcategoriesByPk(subcategoryId: bigint!): Subcategories

  """
  An array relationship
  """
  userGroups(
    """
    distinct select on columns
    """
    distinctOn: [UserGroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserGroupsOrderBy!]

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): [UserGroups!]!

  """
  An aggregate relationship
  """
  userGroupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserGroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserGroupsOrderBy!]

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): UserGroupsAggregate!

  """
  fetch data from the table: "user_groups" using primary key columns
  """
  userGroupsByPk(groupId: bigint!, userId: bigint!): UserGroups

  """
  fetch data from the table: "user_level"
  """
  userLevel(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): [UserLevel!]!

  """
  fetch aggregated fields from the table: "user_level"
  """
  userLevelAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): UserLevelAggregate!

  """
  fetch data from the table: "user_level" using primary key columns
  """
  userLevelByPk(levelId: bigint!, userId: bigint!): UserLevel

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): [Users!]!

  """
  An aggregate relationship
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): UsersAggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  usersByPk(userId: bigint!): Users

  """
  fetch data from the table: "weekdays"
  """
  weekdays(
    """
    distinct select on columns
    """
    distinctOn: [WeekdaysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [WeekdaysOrderBy!]

    """
    filter the rows returned
    """
    where: WeekdaysBoolExp
  ): [Weekdays!]!

  """
  fetch aggregated fields from the table: "weekdays"
  """
  weekdaysAggregate(
    """
    distinct select on columns
    """
    distinctOn: [WeekdaysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [WeekdaysOrderBy!]

    """
    filter the rows returned
    """
    where: WeekdaysBoolExp
  ): WeekdaysAggregate!

  """
  fetch data from the table: "weekdays" using primary key columns
  """
  weekdaysByPk(weekdayId: bigint!): Weekdays
}

input subcategoriesAggregateBoolExpCount {
  arguments: [SubcategoriesSelectColumn!]
  distinct: Boolean
  filter: SubcategoriesBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """
  fetch data from the table: "award"
  """
  award(
    """
    distinct select on columns
    """
    distinctOn: [AwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardOrderBy!]

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): [Award!]!

  """
  fetch aggregated fields from the table: "award"
  """
  awardAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardOrderBy!]

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): AwardAggregate!

  """
  fetch data from the table: "award" using primary key columns
  """
  awardByPk(awardId: bigint!): Award

  """
  fetch data from the table: "award_edition"
  """
  awardEdition(
    """
    distinct select on columns
    """
    distinctOn: [AwardEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardEditionOrderBy!]

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): [AwardEdition!]!

  """
  fetch aggregated fields from the table: "award_edition"
  """
  awardEditionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AwardEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AwardEditionOrderBy!]

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): AwardEditionAggregate!

  """
  fetch data from the table: "award_edition" using primary key columns
  """
  awardEditionByPk(awardId: bigint!, editionId: bigint!): AwardEdition

  """
  fetch data from the table in a streaming manner: "award_edition"
  """
  awardEditionStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [AwardEditionStreamCursorInput]!

    """
    filter the rows returned
    """
    where: AwardEditionBoolExp
  ): [AwardEdition!]!

  """
  fetch data from the table in a streaming manner: "award"
  """
  awardStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [AwardStreamCursorInput]!

    """
    filter the rows returned
    """
    where: AwardBoolExp
  ): [Award!]!

  """
  An array relationship
  """
  bonuses(
    """
    distinct select on columns
    """
    distinctOn: [BonusesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BonusesOrderBy!]

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): [Bonuses!]!

  """
  An aggregate relationship
  """
  bonusesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [BonusesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BonusesOrderBy!]

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): BonusesAggregate!

  """
  fetch data from the table: "bonuses" using primary key columns
  """
  bonusesByPk(bonusId: bigint!): Bonuses

  """
  fetch data from the table in a streaming manner: "bonuses"
  """
  bonusesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [BonusesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: BonusesBoolExp
  ): [Bonuses!]!

  """
  fetch data from the table: "categories"
  """
  categories(
    """
    distinct select on columns
    """
    distinctOn: [CategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: CategoriesBoolExp
  ): [Categories!]!

  """
  fetch aggregated fields from the table: "categories"
  """
  categoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [CategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: CategoriesBoolExp
  ): CategoriesAggregate!

  """
  fetch data from the table: "categories" using primary key columns
  """
  categoriesByPk(categoryId: bigint!): Categories

  """
  fetch data from the table in a streaming manner: "categories"
  """
  categoriesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [CategoriesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: CategoriesBoolExp
  ): [Categories!]!

  """
  fetch data from the table: "category_edition"
  """
  categoryEdition(
    """
    distinct select on columns
    """
    distinctOn: [CategoryEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoryEditionOrderBy!]

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): [CategoryEdition!]!

  """
  fetch aggregated fields from the table: "category_edition"
  """
  categoryEditionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [CategoryEditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [CategoryEditionOrderBy!]

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): CategoryEditionAggregate!

  """
  fetch data from the table: "category_edition" using primary key columns
  """
  categoryEditionByPk(categoryId: bigint!, editionId: bigint!): CategoryEdition

  """
  fetch data from the table in a streaming manner: "category_edition"
  """
  categoryEditionStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [CategoryEditionStreamCursorInput]!

    """
    filter the rows returned
    """
    where: CategoryEditionBoolExp
  ): [CategoryEdition!]!

  """
  fetch data from the table: "chest_award"
  """
  chestAward(
    """
    distinct select on columns
    """
    distinctOn: [ChestAwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestAwardOrderBy!]

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): [ChestAward!]!

  """
  fetch aggregated fields from the table: "chest_award"
  """
  chestAwardAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestAwardSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestAwardOrderBy!]

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): ChestAwardAggregate!

  """
  fetch data from the table: "chest_award" using primary key columns
  """
  chestAwardByPk(chestAwardId: bigint!): ChestAward

  """
  fetch data from the table in a streaming manner: "chest_award"
  """
  chestAwardStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ChestAwardStreamCursorInput]!

    """
    filter the rows returned
    """
    where: ChestAwardBoolExp
  ): [ChestAward!]!

  """
  fetch data from the table: "chest_history"
  """
  chestHistory(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): [ChestHistory!]!

  """
  fetch aggregated fields from the table: "chest_history"
  """
  chestHistoryAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): ChestHistoryAggregate!

  """
  fetch data from the table: "chest_history" using primary key columns
  """
  chestHistoryByPk(chestHistoryId: bigint!): ChestHistory

  """
  fetch data from the table in a streaming manner: "chest_history"
  """
  chestHistoryStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ChestHistoryStreamCursorInput]!

    """
    filter the rows returned
    """
    where: ChestHistoryBoolExp
  ): [ChestHistory!]!

  """
  An array relationship
  """
  chests(
    """
    distinct select on columns
    """
    distinctOn: [ChestsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestsOrderBy!]

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): [Chests!]!

  """
  An aggregate relationship
  """
  chestsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ChestsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ChestsOrderBy!]

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): ChestsAggregate!

  """
  fetch data from the table: "chests" using primary key columns
  """
  chestsByPk(chestId: bigint!): Chests

  """
  fetch data from the table in a streaming manner: "chests"
  """
  chestsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ChestsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: ChestsBoolExp
  ): [Chests!]!

  """
  fetch data from the table: "edition"
  """
  edition(
    """
    distinct select on columns
    """
    distinctOn: [EditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [EditionOrderBy!]

    """
    filter the rows returned
    """
    where: EditionBoolExp
  ): [Edition!]!

  """
  fetch aggregated fields from the table: "edition"
  """
  editionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [EditionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [EditionOrderBy!]

    """
    filter the rows returned
    """
    where: EditionBoolExp
  ): EditionAggregate!

  """
  fetch data from the table: "edition" using primary key columns
  """
  editionByPk(editionId: bigint!): Edition

  """
  fetch data from the table in a streaming manner: "edition"
  """
  editionStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [EditionStreamCursorInput]!

    """
    filter the rows returned
    """
    where: EditionBoolExp
  ): [Edition!]!

  """
  fetch data from the table: "files"
  """
  files(
    """
    distinct select on columns
    """
    distinctOn: [FilesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [FilesOrderBy!]

    """
    filter the rows returned
    """
    where: FilesBoolExp
  ): [Files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  filesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [FilesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [FilesOrderBy!]

    """
    filter the rows returned
    """
    where: FilesBoolExp
  ): FilesAggregate!

  """
  fetch data from the table: "files" using primary key columns
  """
  filesByPk(fileId: bigint!): Files

  """
  fetch data from the table in a streaming manner: "files"
  """
  filesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [FilesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: FilesBoolExp
  ): [Files!]!

  """
  fetch data from the table: "flyway_schema_history"
  """
  flywaySchemaHistory(
    """
    distinct select on columns
    """
    distinctOn: [FlywaySchemaHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [FlywaySchemaHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: FlywaySchemaHistoryBoolExp
  ): [FlywaySchemaHistory!]!

  """
  fetch aggregated fields from the table: "flyway_schema_history"
  """
  flywaySchemaHistoryAggregate(
    """
    distinct select on columns
    """
    distinctOn: [FlywaySchemaHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [FlywaySchemaHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: FlywaySchemaHistoryBoolExp
  ): FlywaySchemaHistoryAggregate!

  """
  fetch data from the table: "flyway_schema_history" using primary key columns
  """
  flywaySchemaHistoryByPk(installedRank: Int!): FlywaySchemaHistory

  """
  fetch data from the table in a streaming manner: "flyway_schema_history"
  """
  flywaySchemaHistoryStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [FlywaySchemaHistoryStreamCursorInput]!

    """
    filter the rows returned
    """
    where: FlywaySchemaHistoryBoolExp
  ): [FlywaySchemaHistory!]!

  """
  An array relationship
  """
  groups(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): [Groups!]!

  """
  An aggregate relationship
  """
  groupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [GroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [GroupsOrderBy!]

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): GroupsAggregate!

  """
  fetch data from the table: "groups" using primary key columns
  """
  groupsByPk(groupsId: bigint!): Groups

  """
  fetch data from the table in a streaming manner: "groups"
  """
  groupsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [GroupsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: GroupsBoolExp
  ): [Groups!]!

  """
  fetch data from the table: "hall_of_fame"
  """
  hallOfFame(
    """
    distinct select on columns
    """
    distinctOn: [HallOfFameSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [HallOfFameOrderBy!]

    """
    filter the rows returned
    """
    where: HallOfFameBoolExp
  ): [HallOfFame!]!

  """
  fetch aggregated fields from the table: "hall_of_fame"
  """
  hallOfFameAggregate(
    """
    distinct select on columns
    """
    distinctOn: [HallOfFameSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [HallOfFameOrderBy!]

    """
    filter the rows returned
    """
    where: HallOfFameBoolExp
  ): HallOfFameAggregate!

  """
  fetch data from the table in a streaming manner: "hall_of_fame"
  """
  hallOfFameStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [HallOfFameStreamCursorInput]!

    """
    filter the rows returned
    """
    where: HallOfFameBoolExp
  ): [HallOfFame!]!

  """
  An array relationship
  """
  levels(
    """
    distinct select on columns
    """
    distinctOn: [LevelsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LevelsOrderBy!]

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): [Levels!]!

  """
  An aggregate relationship
  """
  levelsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LevelsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LevelsOrderBy!]

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): LevelsAggregate!

  """
  fetch data from the table: "levels" using primary key columns
  """
  levelsByPk(levelId: bigint!): Levels

  """
  fetch data from the table in a streaming manner: "levels"
  """
  levelsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [LevelsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: LevelsBoolExp
  ): [Levels!]!

  """
  An array relationship
  """
  points(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): [Points!]!

  """
  An aggregate relationship
  """
  pointsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsOrderBy!]

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): PointsAggregate!

  """
  fetch data from the table: "points" using primary key columns
  """
  pointsByPk(pointsId: bigint!): Points

  """
  fetch data from the table: "points_history"
  """
  pointsHistory(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): [PointsHistory!]!

  """
  fetch aggregated fields from the table: "points_history"
  """
  pointsHistoryAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PointsHistorySelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PointsHistoryOrderBy!]

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): PointsHistoryAggregate!

  """
  fetch data from the table: "points_history" using primary key columns
  """
  pointsHistoryByPk(pointsHistoryId: bigint!): PointsHistory

  """
  fetch data from the table in a streaming manner: "points_history"
  """
  pointsHistoryStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [PointsHistoryStreamCursorInput]!

    """
    filter the rows returned
    """
    where: PointsHistoryBoolExp
  ): [PointsHistory!]!

  """
  fetch data from the table in a streaming manner: "points"
  """
  pointsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [PointsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: PointsBoolExp
  ): [Points!]!

  """
  An array relationship
  """
  subcategories(
    """
    distinct select on columns
    """
    distinctOn: [SubcategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SubcategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): [Subcategories!]!

  """
  An aggregate relationship
  """
  subcategoriesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SubcategoriesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SubcategoriesOrderBy!]

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): SubcategoriesAggregate!

  """
  fetch data from the table: "subcategories" using primary key columns
  """
  subcategoriesByPk(subcategoryId: bigint!): Subcategories

  """
  fetch data from the table in a streaming manner: "subcategories"
  """
  subcategoriesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [SubcategoriesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: SubcategoriesBoolExp
  ): [Subcategories!]!

  """
  An array relationship
  """
  userGroups(
    """
    distinct select on columns
    """
    distinctOn: [UserGroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserGroupsOrderBy!]

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): [UserGroups!]!

  """
  An aggregate relationship
  """
  userGroupsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserGroupsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserGroupsOrderBy!]

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): UserGroupsAggregate!

  """
  fetch data from the table: "user_groups" using primary key columns
  """
  userGroupsByPk(groupId: bigint!, userId: bigint!): UserGroups

  """
  fetch data from the table in a streaming manner: "user_groups"
  """
  userGroupsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [UserGroupsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: UserGroupsBoolExp
  ): [UserGroups!]!

  """
  fetch data from the table: "user_level"
  """
  userLevel(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): [UserLevel!]!

  """
  fetch aggregated fields from the table: "user_level"
  """
  userLevelAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserLevelSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserLevelOrderBy!]

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): UserLevelAggregate!

  """
  fetch data from the table: "user_level" using primary key columns
  """
  userLevelByPk(levelId: bigint!, userId: bigint!): UserLevel

  """
  fetch data from the table in a streaming manner: "user_level"
  """
  userLevelStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [UserLevelStreamCursorInput]!

    """
    filter the rows returned
    """
    where: UserLevelBoolExp
  ): [UserLevel!]!

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): [Users!]!

  """
  An aggregate relationship
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): UsersAggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  usersByPk(userId: bigint!): Users

  """
  fetch data from the table in a streaming manner: "users"
  """
  usersStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [UsersStreamCursorInput]!

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): [Users!]!

  """
  fetch data from the table: "weekdays"
  """
  weekdays(
    """
    distinct select on columns
    """
    distinctOn: [WeekdaysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [WeekdaysOrderBy!]

    """
    filter the rows returned
    """
    where: WeekdaysBoolExp
  ): [Weekdays!]!

  """
  fetch aggregated fields from the table: "weekdays"
  """
  weekdaysAggregate(
    """
    distinct select on columns
    """
    distinctOn: [WeekdaysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [WeekdaysOrderBy!]

    """
    filter the rows returned
    """
    where: WeekdaysBoolExp
  ): WeekdaysAggregate!

  """
  fetch data from the table: "weekdays" using primary key columns
  """
  weekdaysByPk(weekdayId: bigint!): Weekdays

  """
  fetch data from the table in a streaming manner: "weekdays"
  """
  weekdaysStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [WeekdaysStreamCursorInput]!

    """
    filter the rows returned
    """
    where: WeekdaysBoolExp
  ): [Weekdays!]!
}

scalar time

scalar timestamp

input userGroupsAggregateBoolExpCount {
  arguments: [UserGroupsSelectColumn!]
  distinct: Boolean
  filter: UserGroupsBoolExp
  predicate: IntComparisonExp!
}

input userLevelAggregateBoolExpCount {
  arguments: [UserLevelSelectColumn!]
  distinct: Boolean
  filter: UserLevelBoolExp
  predicate: IntComparisonExp!
}

input usersAggregateBoolExpCount {
  arguments: [UsersSelectColumn!]
  distinct: Boolean
  filter: UsersBoolExp
  predicate: IntComparisonExp!
}
